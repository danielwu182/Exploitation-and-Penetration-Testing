# 6-漏洞挖掘

## 静态检测

软件静态安全检测技术是`针对未处于运行状态的软件`所开展的安全分析测试技术。静态安全检测技术可以用于对软件`源代码`和`可执行代码`的检测。

### 源代码的检测

静态安全检测技术是软件源代码的主要安全检测技术。

优
- 不需要构建代码运行环境
- 分析效率高，资源消耗低

缺
- 存在较高的误报率，但仍然在很大程度上减少了人工分析的工作量。

目前常用的静态安全检测技术：
- 词法分析
- 数据流分析
- 污点传播
- 符号执行
- 模型检查
- 定理证明

1. 词法分析

	词法分析对源代码进行 **基于文本或字符标识的匹配分析对比，以查找符合特定特征和词法规则的危险函数、API或简单语句组合**

	词法分析能够开展针对词法方面的快速检测，算法简单，检测性能较高，然而这种分析技术只能进行表面的词法检测，而不能进行语义方面的深层次分析，因此可以检测的安全缺陷和漏洞较少，会出现较高的漏报和误报，尤其对于高危漏洞无法进行有效检测。

	使用该技术的源代码安全检测工具包括 `Checkmarx`和 `ITS4`等。

2. 数据流分析

	数据流分析通过 **分析软件代码中变量的取值变化和语句的执行情况，来分析数据处理逻辑和程序的控制流关系，从而分析软件代码的潜在安全缺陷**
	
	数据流分析首先将代码构造为`抽象语法树`或`程序控制流图`，接着追踪获取变量的变化信息，描述程序的运行行为，进而根据事先定义的安全规则检测出安全缺陷和漏洞。
	
	**数据流分析适合检查因控制流信息非法操作而导致的安全问题**，如内存访问越界、常数传播等。由于对于逻辑复杂的软件代码，其数据流复杂，并呈现多样性的特点，因而检测的准确率较低，误报率较高。但是该方法具有较高的可行性，并且可实现针对大规模代码的快速分析，因此广泛应用于商业的源代码安全性分析工具中。

	`Coverity`、 `Klockwork`等商业工具均使用了该技术进行源代码安全检测。

3. 污点传播分析

	污点传播分析通过 **分析代码中输入数据对程序执行路径的影响，以发现不可信的输入数据导致的程序执行异常**
	
	污点数据为需要进行标记分析的输入数据，污点传播首先对污点数据进行标记，并静态跟踪程序代码中污点数据的传播路径，发现使用污点数据的不安全执行路径，进而分析出由于非法数据的使用而引发的输入异常类漏洞。污点传播分析的核心是**分析输入参数和执行路径之间的关系**，它适用于由输入参数引发漏洞的检测。污点传播分析技术具有较高的分析准确率，然而针对大规模代码的分析，由于路径数量较多，因此其分析的性能会受到较大的影响。

	`Pixy` 是使用该技术的典型软件工具。

4. 符号执行

	符号执行是指在 **不实际执行程序的前提下，将程序的输入表示成符号，根据程序的执行流程和输入参数的赋值变化，把程序的输出表示成包含这些符号的逻辑或算术表达式的一种技术**
	
	通过符号执行技术获得了程序输出和输入之间关系的算术表达式，可通过约束求解的方法获得能得出正常输出结果的输入值的范围。不能得到正常输出的输入值，或者输入值范围的边界点，则是触发程序输出异常结果的潜在输入点，也是进行安全性检测的重要检测区域。
	
	符号执行有代价小、效率高的优点，然而由于程序执行的可能路径随着程序规模的增大呈指数级增长，从而导致符号执行技术在分析输入和输出之间关系时，存在一个**路径状态空间的爆炸**问题，路径爆炸问题在现有计算能力的条件下很难解决。由于符号执行技术进行路径敏感的遍历式检测，当程序执行路径的数量超过约束求解工具的求解能力时，符号执行技术将难以分析。

	使用了符号执行进行源码检测的工具有`EXE`、`SAGE`、`SMART`以及 `KLEE`等。

5. 模型检验

	模型检验是 **将程序的执行过程抽象为状态迁移的模型，采用状态迁移过程中安全属性的验证来判断程序的安全性质**
	
	模型检验技术首先将软件构造为状态机或者有向图等抽象模型，并使用模态/时序逻辑公式等形式化的表达式来描述安全属性，然后对模型进行遍历以验证软件的这些安全属性是否满足。
	
	模型检验对于路径和状态的分析过程可以实现全自动化；但是由于穷举所有状态，所以同样存在计算能力受限的问题。由于模型检验技术面临着状态空间爆炸的问题，在对大型复杂软件的漏洞挖掘方面仍处于探索阶段。此外，对时序、路径等属性，在边界处的近似处理难度也较大。

	微软公司的`SLAM`项目、伯克利大学的 `MOPS`工具等都是典型的代表性工具。

6. 定理证明

	定理证明是 **将待验证问题转化为数学上的定理证明问题，从而判定程序是否满足特定安全属性**
	
	定理证明的方法通过将程序转换并表示为逻辑公式，然后使用公理和规则证明的方法，验证程序是否为一个合法的定理，从而发现其中无法证明的部分，从中发现安全缺陷。定理证明的方法整个过程都使用严格的推理证明实现分析，在静态分析技术中是最准确的，误报率较低。然而该技术抽象和转换工作需要人工干预，自动化程度不高，难以应用于新漏洞的检测，而且难以应用于大型程序分析。

	使用该技术的安全检测工具包括 `Saturn`、`ESC/Java`等。

### 可执行代码检测

针对软件可执行代码的静态安全检测，只能对可执行代码反汇编后得到的汇编代码进行检测，而汇编代码中多是寄存器之间数值的操作，没有明确的语义信息，因此静态安全检测技术往往分析效率低下，误报率较高。

可执行代码的静态安全检测技术可分为**基于程序结构的安全检测技术**和**基于程序语义的安全检测技术**。

- 基于程序结构的安全检测技术

	基于程序结构的安全检测技术需要根据二进制可执行文件的格式特征，从二进制文件的头部、符号表以及调试信息中提取安全敏感信息，来分析文件中是否存在安全缺陷。

	`IDA Pro` 反汇编工具，它能够对可执行代码的静态安全检测分析提供一定的辅助作用。`Bugscam`检测工具能够基于`IDA Pro`对被测试程序进行安全缺陷检测。它采用了基于程序结构的安全检测技术，通过使用 `IDA Pro`提供的函数调用信息和代码引用信息，定位程序中调用`strcpy`、`memcpy`、`sprintf`等危险函数的代码位置，再通过分析传入的参数信息判断是否存在缓冲区溢出漏洞或者格式化字符串漏洞。

- 基于程序语义的安全检测技术

	基于程序语义的安全检测技术，需要先对程序进行反汇编得到汇编代码，再将汇编代码转换为中间语言，在分析中间语言的基础上针对得到的部分语义信息进行缺陷和漏洞的检测。由于在不同的操作系统上，二进制可执行文件的格式不同，所以基于程序语义的分析方法得益于其跨平台性而受到广泛的研究。

	出于对x86指令集复杂性的考虑，基于程序语义的安全检测技术在汇编代码的基础上作进一步抽象，首先将二进制指令翻译为中间语言。然后对中间语言进行静态分析。目前使用最为广泛的两种中间语言是二进制插装平台 `Binnavi`中使用的 `REIL`，和动态插装平台`Valgrind`中使用的 `VEX`。

	`UAFChecker`检测工具采用了基于程序语义的安全检测技术，它能够对浏览器软件中常见的`Use-After-Free`漏洞进行静态检测。它首先将`IDA Pro`反汇编得到的汇编代码转换为中间语言，然后再建立 `USE-DEFINE`和 `DEFINE-USE`链，通过结合数据流分析遍历这两个链，来检测程序中是否存在对被释放资源的使用。

## 静态检测实践

### 基于逆向分析的静态检测

对于可执行文件，通过逆向分析得到其反汇编代码，对这些代码进行静态检测的过程通常包括三个步骤：

- 使用逆向分析工具，比如IDA，得到其反汇编后的执行代码；
- 定位敏感函数，也就是容易出现溢出的函数，比如memcpy、strcpy等；
- 判断栈空间大小、参数大小，分析是否存在溢出的可能。

### IDA脚本在漏洞挖掘中的应用

`IDA`的脚本语言叫做`ID`C，与C语言的语法非常相似

简单讲，`IDC`脚本主要是一个在`IDA`的反汇编基础上，建立起来的自动化代码分析过程。`IDA`可以依据这个脚本中的指令来完成自动化的操作，所有使用`IDA`进行程序分析的人都可以将自己的操作过程脚本化，这样别人只需要安装该脚本就可以完成某项分析了。

`Bugscam`是一个IDA工具的`idc`脚本的轻量级的漏洞分析工具。是通过检测栈溢出漏洞的诸如`strcpy`,`sprintf`危险函数的位置，然后根据这些函数的参数，确定是否有缓冲区漏洞。

`Bugscam`是一个十年前写的对于`strcpy`等函数的自动化漏洞检测脚本，是一个压缩文件。使用方法：

1. 将Bugscam文件解压放到任意地方，然后修改`globalvar.idc`文件中头行的`bugscam_dir`为你的`bugscam`目录的全路径。在`analysis_scripts`路径下可以看到待检测的各个函数，将这些函数中的`#include "idc/bugscam/libaudit.idc"`修改为`#include "../libaudit.idc"`。在bugscam路径下可以看到`libaudit.idc`文件，将其中的`#include "bugscam/globalvar.idc"`修改为`#include "globalvar.idc"`。

2. 启动`ida`，加载任意一个`x86`程序文件，然后打开脚本文件`run_analysis.idc`，运行即可，等待分析完毕，最后的分析报告结果保存在`reports`目录中的html文件中。

检测结果类似如下：

Results for _strcpy

The following table summarizes the results of the analysis of calls to the function _strcpy.
|Address	|Severity	|Description|
|:--|:--|:--|
|401e52	|2	|UNKNOWN_DESTINATION_SIZE: The analyzer was unable to determine the size of the destination; This location should be investigated manually.|

Results for lstrcpyA

The following table summarizes the results of the analysis of calls to the function lstrcpyA.
|Address	|Severity	|Description|
|:---|:---|:---|
|401010	|8	|The maximum possible size of the target buffer (203) is smaller than the minimum possible size of the source buffer (1024). This is VERY likely to be a buffer overrun!|
|401010	|8	|The maximum possible size of the target buffer (203) is smaller than the minimum possible size of the source buffer (1024). This is VERY likely to be a buffer overrun!|

### 基于Hook的检测方法

溢出漏洞的发掘入手点在于捕捉关键函数及其参数内容，那么在这些函数上能不能放上一个监视点呢？使用Hook技术就可以达成该目的。

钩子(`Hook`)，是`Windows`消息处理机制的一个平台,应用程序可以在上面设置子程以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。  **钩子机制允许应用程序截获处理window消息或特定事件**

钩子(`Hook`)，既然是位于消息被正式处理之前，那么它同样可以用于函数被正式调用之前，也就是说我们可以在那些操作栈的关键函数上加上钩子，将它们换成我们的函数实现，这样我们就可以做到真正的动态监视。

注意：API HOOK 技术不仅仅在这里有用，它也常常被用到计算机病毒当中。计算机病毒经常使用这个技术来达到隐藏自己的目的。

![](https://github.com/braveghz/Exploitation-and-Penetration-Testing/blob/master/images/6-1.png)

使用HOOK技术，可以使得原有的调用`strcpy`的函数，变成调用我们自己的相关函数，而我们自己的相关函数可以有效的记录相关的执行行为，进而为漏洞检测提供基础数据。

如何实现一般函数的`HOOK`？

首先，了解`API HOOK`和`PE`文件的关系

`Api hook`技术的难点，并不在于hook技术，而在于对PE结构的学习和理解。如何修改api函数的入口地址？这就需要学习PE可执行文件如何被系统映射到进程空间中，学习PE格式的基本知识。

PE文件提供了一个输入符号表`imported symbols table`来定义了所调用的函数的入口地址。   

|pe格式的基本组成| |
|:---|:---|
|DOS文件头|以4D5A的16进制即`MZ`开头|
|PE文件头|以50450000的`PE00`开头|
|可选头文件|包含下面的数据目录|
|数据目录|函数入口地址 / 基地址 / 内存 / 文件对齐粒度之类信息|
|节表|维护一个所有节的信息|
|节表1|具有同类特征的信息，文件的主体部分|
|节表2|	　|
|...|	|
|节表n|	|

我们需要从数据目录数组中的第二个元素——输入符号表的位置，它是一个`IMAGE_DATA_DIRECTORY`结构，从它中的`VirtualAddress`地址，找到api函数的入口地点。

使用`LordPE`打开一个PE文件 -- 点目录，可以看到目录表 -- 点输入表的右侧第一个按钮，可以看到所调用的函数的入口信息

所调用的函数，主要由两部分：DLL文件及DLL文件中的函数。因此，DLL注入是HOOK的一个基本实现方法。

这样的话，一种实现HOOK的方式就是：

- 利用DLL注入，定义自己的函数。比如，我们想将`KERNEL32.DLL`的函数进行`HOOK`，那么使用VC IDE建立一个DLL动态链接库工程，将相关的函数按照`KERNEL32.DLL`中的函数原型进行重新定义，命名为自己的函数
- 利用有关工具改写PE文件中的函数调用信息

----

## 动态检测

软件动态安全检测技术是**针对运行中的软件程序，通过 构造非正常的输入 来检测软件运行时是否出现故障或崩溃等非正常的输出，并通过检测软件运行中的内部状态信息来验证或者检测软件缺陷的过程**，它的分析对象是可执行代码。

动态安全检测技术是通过实际运行发现问题，所以检测出的安全缺陷和漏洞准确率非常高，误报率很低。

- 模糊测试
- 智能模糊测试
- 动态污点跟踪

### 模糊测试

模糊测试(`Fuzzing`)是一种自动化或半自动化的安全漏洞检测技术，**通过向目标软件输入大量的畸形数据并监测目标系统的异常来发现潜在的软件漏洞**

模糊测试属于黑盒测试的一种，它是一种有效的动态漏洞分析技术，黑客和安全技术人员使用该项技术已经发现了大量的未公开漏洞。

它的缺点是畸形数据的生成具有随机性，而随机性造成代码覆盖不充分导致了测试数据覆盖率不高。

知名的模糊测试工具包括`SPIKE`、`Peach`等。

模糊测试需要根据目标程序的多种因素而选择不同的方法，这些因素包括目标程序不同的输入、不同的结构信息、研究者的技能以及需要测试数据的格式等。然而不管针对何种目标程序采取何种方法，通常的模糊测试过程基本都采用以下几个通用的步骤。

1. 确定测试对象和输入数据

	由于所有可被利用的漏洞都是由于应用程序接受了用户输入的数据造成的，并且在处理输入数据时没有首先过滤非法数据或者进行校验确认。对模糊测试来说首要的问题是确定可能的输入数据，畸形输入数据的枚举对模糊测试至关重要。所有应用程序能够接收的数据都应该被认为是输入数据，主要包括文件、网络数据包、注册表键值、环境变量、配置文件和命令行参数等，这些都是可能的模糊测试输入数据。

2. 生成模糊测试数据

	一旦确定了输入数据，接着就可以生成模糊测试用的畸形数据。根据目标程序及输入数据格式的不同，可相应选择不同的测试数据生成算法。例如，可采用预生成的数据，也可以通过对有效数据样本进行变异，或是根据协议或文件格式动态生成畸形数据。无论采用哪种方法，此过程都应该采用自动化的方式完成。

3. 检测模糊测试数据

	检测模糊测试数据的过程首先要启动目标程序，然后把生成的测试数据输入到应用程序中进行处理。在这个过程中实现自动化也是必需的和十分重要的。

4. 监测程序异常

	在模糊测试过程中，一个非常重要但却经常被忽视的步骤是对程序异常的监测。实时监测目标程序的运行，就能追踪到引发目标程序异常的源测试数据。异常的监测可以采用多种方法，包括操作系统的监测功能以及第三方的监测软件。

5. 确定可利用性

	一旦监测到程序出现的异常，还需要进一步确定所发现的异常情况是否能被进一步利用。这个步骤不是模糊测试必需的步骤，只是检测这个异常对应的漏洞是否可以被利用。这个步骤一般由手工完成，需要分析人员具备深厚的漏洞挖掘和分析经验。

	所有类型的模糊测试技术，除了最后一步确定可利用性外，所有其它的四个阶段都是必须的。尽管模糊测试对安全缺陷和漏洞的检测能力很强，但并不是说它对被测软件都能发现所有的错误，原因就是它测试样本的生成方式具有随机性。为了弥补它的这个缺点，有实力的研究机构和公司采用了多台测试服务器组成的集群进行分布式协同测试，甚至测试用的服务器达到几十台。通过这种增加物理资源的手段，在一定程度上弥补了模糊测试的不足。

上述典型的`fuzzing`测试流程如下图所示。

![](https://github.com/braveghz/Exploitation-and-Penetration-Testing/blob/master/images/6-2.PNG)


### 智能模糊测试

模糊测试方法是应用最普遍的动态安全检测方法，但由于模糊测试数据的生成具有随机性，缺乏对程序的理解，测试的性能不高，并且难以保证一定的覆盖率。为了解决这个问题，引入了基于符号执行等可进行程序理解的方法，在实现程序理解的基础上，有针对性的设计测试数据的生成，从而实现了比传统的随机模糊测试更高的效率，这种结合了程序理解和模糊测试的方法，称为智能模糊测试(`smart Fuzzing`)技术。

智能模糊测试具体的实现步骤

1. 反汇编

	智能模糊测试的前提，是对可执行代码进行输入数据、控制流、执行路径之间相关关系的分析。为此，首先对可执行代码进行反汇编得到汇编代码，在汇编代码的基础上才能进行上述分析。

2. 中间语言转换

	从汇编代码中直接获取程序运行的内部信息，工作量较大，为此，需要将汇编代码转换成中间语言，由于中间语言易于理解，所以为可执行代码的分析提供了一种有效的手段。

3. 采用智能技术分析输入数据和执行路径的关系

	这一步是智能模糊测试的关键，它通过符号执行和约束求解技术、污点传播分析、执行路径遍历等技术手段，检测出可能产生漏洞的程序执行路径集合和输入数据集合。例如，利用符号执行技术在符号执行过程中记录下输入数据的传播过程和传播后的表达形式，并通过约束求解得到在漏洞触发时执行的路径与原始输入数据之间的联系，从而得到触发执行路径异常的输入数据。

4. 利用分析获得的输入数据集合，对执行路径集合进行测试

采用上述智能技术获得的输入数据集合进行安全检测，使后续的安全测试检测出安全缺陷和漏洞的机率大大增加。与传统的随机模糊测试技术相比，这些智能模糊测试技术的应用，由于了解了输入数据和执行路径之间的关系，因而生成的输入数据更有针对性，减少了大量无关测试数据的生成，提高了测试的效率。此外，在触发漏洞的同时，智能模糊测试技术包含了对漏洞成因的分析，极大减少了分析人员的工作量。

智能模糊测试的核心思想在于以尽可能小的代价找出程序中最有可能产生漏洞的执行路径集合，从而避免了盲目地对程序进行全路径覆盖测试，使得漏洞分析更有针对性。智能模糊测试技术的提出，反映了软件安全性测试由模糊化测试向精确化测试转变的趋势。然而，智能模糊测试在分析可能产生漏洞的执行路径时，从技术实现、编码工作量和提升分析的准确性方面，都有很大难度和提升空间，并且将花费大量的时间成本和人力，所以使用该技术时需要衡量在工作量和安全检测效率之间的关系。

### 动态污点分析

模糊测试技术侧重随机生成数据样本并测试，它不关注程序真实的执行过程。动态污点分析(`dynamic taint analysis`)技术则通过分析被测试程序内部指令真实的执行过程，追踪输入数据在程序内部的传递、处理流程，以检测输入数据是否存在涉及安全的敏感操作，从而分析出污点数据导致的潜在安全缺陷和漏洞。

动态污点分析的基本思想是在程序的执行过程中跟踪用户的输入数据在寄存器和内存单元之间的传播过程，然后监控被测试程序对输入数据使用的相关信息。

动态污点分析关注所有来自程序外部的不可信污点数据在可执行程序中的传播过程，对所有的不可信污点数据都标记一个唯一的标签，然后跟踪这些标签在可执行程序中的传递过程。在跟踪这些标签在二进制程序中传播的过程时，不仅考虑二进制程序中的数据依赖关系，而且考虑二进制程序中不同变量之间的控制依赖关系。动态污点分析技术可以识别出输入文件中的哪些字节会影响二进制程序中涉及安全敏感操作的函数，诸如内存分配函数、字符串函数和其它的一些函数，从而发现可能触发安全缺陷和漏洞的污点数据。

### 动态检测实践

1. 使用`FileFuzz`工具进行文件模糊测试

	`Fuzzer`:文件型Fuzzer、网络型Fuzzer、接口型Fuzzer等。

	文件型Fuzzer主要针对有文件作为程序输入的情况下的Fuzzing。 对于可读的文件，你可以使用改变其内容的具体数值来进行Fuzzing；对于未公布格式的，你可以按照一定规律修改文件格式来进行Fuzzing。比较知名的文件型Fuzzer工具是`FileFuzz`。

	非明文格式特殊文件：对于一些文字处理型软件来说，其所处理的特殊文件中保存的信息是以明文的形式保存的，例如`Windows`系统自带的记事本程序，通常该文字处理型软件所处理的特殊文档格式为TXT格式，我们随意打开一个TXT格式的文件就可以直接看到其中保存的文字信息。而出于商业利益和安全上的考虑，很多文字处理型软件采用非明文的方式保存信息，例如`Microsoft Office PowerPoint`。我们用记事本打开一个ppt文档，会发现全是乱码。

	这种非明文形式编码格式目的确保用户只有利用与文档文件相匹配的文件处理软件才能正确读取文字或图片信息，防止数据泄露。这种非明文形式的编码意味着只有文件处理的开发者知道如何解释这些编码格式，而作为漏洞挖掘者无从知晓，而文件处理软件的漏洞往往发生在软件处理文档文件的过程中，例如文档中某个地方数据过长就可能造成软件发成溢出漏洞。

	如果文档文件采用非明文形式的编码，我们无法通过记事本这样的程序来修改，但是利用十六进制编辑软件，我们依旧可以修改这些非明文形式的文档文件。例如，我们用`UltraEdit`打开PPT文件。

	**介绍如何利用自动化工具发掘软件漏洞**

	使用`FileFuzz`发掘文字处理软件漏洞：`FileFuzz`是iDefense安全公司开发的一款专门用来发掘文件处理型软件安全漏洞的测试工具。Fuzz的思想就是利用“暴力”来实现对目标程序的自动化测试，然后监视检查其最后的结构，如果符合某种情况，就认为程序可能存在某种安全漏洞。这里说的“暴力”指不断向目标程序发送或者传递不同格式的数据，来测试目标程序的反应。FileFuzz采用字节替换法批量生产待测文档文件，然后将这些待测文档文件逐一调用相应文件处理软件打开，同时监视打开过程中发生的错误，并将错误结果记录下来。

	在使用`FileFuzz`程序之前，首先需要在自己的计算机系统上安装好`.Net Framework`组件包。

	在使用中，如果想要测试自己选定的文字处理型软件，那么就需要向`FileFuzz`添加被测试软件的名称以及软件所在的位置。具体的添加方法为：打开`FileFuzz`程序的安装目录，默认为：`C:\ProgramFiles\iDefense\FileFuzz`。在该目录下，有一个名叫`targets.xml` -- 配置文件,在这里添加想要测试的软件的信息。以测试微软的`Microsoft Office PowerPoint 2003`为例,找到`</fuzz>`这一行，在它前面添加：

	![](https://github.com/braveghz/Exploitation-and-Penetration-Testing/blob/master/images/6-3.png)

	- `<name></name>`:被测试软件及其处理文件类型的名称
	- `<fileName>+<fileDescription>`:填写被测试文件类型
	- `<sourceFile>以及<sourceDir>`:由于FileFuzz程序利用了直接暴力方式修改测试的思想，那么它首先需要一个进行修改的原始文档文件，然后将对这个 文件进行不断地修改保存，接着将这些保存后的文件作为测试文件让被测试软件打开，从而发现软件存在的漏洞。
	- `<app>`:填写被测试文件处理型软件的程序名称，以及程序所在的物理路径信息。
	- `<target>`:指被测试文件所在的路径，这里保持与`<sourceDir>`一栏一致。

	保持修改后的`targets.xml`的文件，然后重新运行`FileFuzz`程序，这时就能够在软件上方的列表中找到想要测试的文字处理型软件，如图

	![](https://github.com/braveghz/Exploitation-and-Penetration-Testing/blob/master/images/6-4.png)

	在C盘ppt2003目录下建立原始文档文件`test.ppt`，这里演示漏洞MS06-028。请暂时重新安装到SP2的最初版本11.6564.6568，以便测试分析。

	新建一个空白的`test.ppt`文件，用分别以单、双字节的0f进行fuzz，能重现这个漏洞。

	![](https://github.com/braveghz/Exploitation-and-Penetration-Testing/blob/master/images/6-5.png)

	`FileFuzz`配置成上图。

	- `Target`：用来替换原始文档文件内容的数据，这里修改为0f、2个字节。
	- `Scope`：关于修改模式的选项
		- `All Bytes`是逐个字节修改
		- `Range`是对原始文档文件的某个范围进行修改
		- `Depth`是按照阶梯的形式来修改原始文档文件
		- `Match`则是使用替换指定字节的方式来生产测试文件

	单击`Create`按钮，`FileFuzz`就会按照要求在`<targetDir>`栏指定的目录下生成测试文件，如下图。

	![](https://github.com/braveghz/Exploitation-and-Penetration-Testing/blob/master/images/6-6.png)

	生成待测文件后，以进行Fuzz测试。

	单击`Execute`按钮，切换到测试面板，并将`Start File`和`Finish File`修改为刚刚生成的测试文件的起始序号。

	接下来单击`Execute`按钮，`FileFuzz`将会开始进行自动化的安全测试工作。一旦`FileFuzz`检测到被测试软件在处理某个测试文件时发生了错误，`FileFuzz`程序会马上在程序的最下方显示错误信息，如下图所示。

	![](https://github.com/braveghz/Exploitation-and-Penetration-Testing/blob/master/images/6-7.png)

	`FileFuzz`程序在很大程度上简化了我们手工发掘文字处理型软件漏洞的过程，自动化的程序测试可以节省大量的时间。

2. 自动动手写简单的Fuzzer程序

	1. 判断目标程序的需要
	2. 思考提供什么样的数据作为测试
	3. 如何实现暴力测试
	4. 如何获得结果，结果如何输出

	overflow.exe
	```c
	#include <stdio.h>
	#include <string.h> 
	void overflow(char *b)
	{
		char des[50];
		strcpy(des,b);
	}
	void main(int argc,char *argv[])
	{
		if(argc>1) 
			overflow(argv[1]);
		else 
			printf("usage: overflow XXXXX\n");
	}
	```
	对该exe文件进行模糊测试的话，根据该`exe`文件要求提供一个输入字符串、对字符串格式无要求的事实，所编写的`Fuzzer`只需要构造不同长度的输入字符串就可以达到模糊测试的目的。

	明确了输入的要求和暴力测试的循环条件后，可以写出如下的代码
	```c
	#include <stdio.h>
	#include <windows.h> 
	void main(int argc,char *argv[])
	{ 
		char *testbuf="";
		char buf[1024];
		memset(buf,0,1024); 
		if(argc>2)
		{ 
			for(int i=20;i<50;i=i+2)
			{
			testbuf=new char[i];
			memset(testbuf,0,i);
			memset(testbuf,'c',i); 
			memcpy(buf,testbuf,i);
			//printf("%s\n",buf);
			ShellExecute(NULL,"open",argv[1],buf,NULL,SW_NORMAL);
			delete testbuf;
			} 
		}
		else printf("Fuzzing X 1\n其中X为被测试目标程序所在路径，1代表开始循环递增暴力测试");
	}
	```
	通过一个`for`循环构造不同的字符串作为输入，通过`ShellExecute(NULL,"open",argv[1],buf,NULL,SW_NORMAL);`来实现对目标程序的模糊测试。

	上述`Fuzzer`的调用格式为：`Fuzzing X 1`。`X`表示目标程序，`1`表示递增暴力测试。


## 动静结合检测

目前普遍应用的动静结合安全检测技术主要包括两种

1. 第一种是先对源代码进行静态分析，发现潜在的漏洞，然后构造输入数据在程序动态运行时验证其真实性。这种方法没有更多地发挥动态分析的作用。
2. 第二种是对可执行代码进行反汇编，通过对汇编代码或者中间语言进行静态检测分析获取的信息指导动态漏洞分析。这种办法结合了动态污点分析技术的优点，然而汇编代码的语义信息较难提取，并且跟踪可执行代码运行信息的技术难度较大。

将动态分析和静态分析结合起来对二进制进行分析，这种技术比单纯的动态和静态分析更加复杂，比较有代表性的是`BitBlaze`。

`BitBlaze`由三部分组成：`TEMU`，`VINE`和`Rudder`。

- `TEMU`是`BitBlaze`的动态分析模块，其实质是一个虚拟机，可执行程序在该虚拟机上执行，并记录下执行的指令、操作数等，生成追踪的记录。`TEMU`借助虚拟机实现了全系统模拟，不但可以跟踪用户控件的指令流，而且可以跟踪进入系统内核，记录其指令流和操作数。

- `VINE`是`BitBlaze`的静态分析模块，它分为前端和后端两部分，前端将二进制指令提升为`VINE`中间语言(`VINE Intermediate Language: VINEIL`)。后端用来在`VINEIL`上做静态分析，包括函数调用图和控制流图建立，数据流分析，符号执行等。此外，`VINE`的后端模块记录追踪路径的约束条件，可将某个路径约束取反，生成满足新路径约束条件的输入，供`Rudde`r模块使用。

- `Rudder`模块层次在`TEMU`和`VINE`模块之上，是一个混合进行符号执行和实际执行的一个模块。如果检测到符号输入影响到执行路径的选择，`Rudde`r会将具体执行和符号执行结合起来，探测多条可执行的路径。探测多条路径的具体过程是，`Rudder`首先随机生成一个输入数据，利用`TEMU`进行跟踪，利用`VINE`记录路径约束，然后将其中的约束条件取反，利用约束求解器生成能够满足新的路径约束的输入数据，再将`TEMU`追踪该输入数据，如此循环往复，从而保证每次的输入数据执行的是一条尚未执行过的路径。`BitBlaze`本质上是一个动态`Fuzzing`工具，它可以保证每次执行的都是不同的路径，以此来提高测试的有效性。