5.1漏洞利用概念
1. 有关概念
（1）概念
漏洞利用，即exploit。Exploit 的英文意思就是利用，它在黑客眼里就是漏洞利用。有漏洞不一定就有Exploit（利用），但是有Exploit就肯定有漏洞。
假设，刚刚发现了一个Minishare 1.4.1版的0Day漏洞。Minishare是一款文件共享软件（Homepage - http://minishare.sourceforge.net/），该0Day漏洞是一个缓冲区溢出漏洞，这个漏洞影响1.4.2之前的所有版本。当用户向服务器发送的报文长度过大（超过堆栈边界）时就会触发该漏洞。
得到该漏洞后，可以做点什么呢？善意点的，可以对同学或者朋友的电脑搞搞恶作剧，让他的电脑弹出个对话框之类的。恶意的话，可以利用这个漏洞来向目标机器植入木马，窃听用户个人隐私等。那么，到底如何能达成这些目的呢？
（2）漏洞利用的手段
在1996年，Aleph One在Underground发表了著名论文《SMASHING THE STACK FOR FUN AND PROFIT》，其中详细描述了Linux系统中栈的结构和如何利用基于栈的缓冲区溢出。在这篇具有划时代意义的论文中，Aleph One演示了如何向进程中植入一段用于获得shell（Shell是系统的用户界面,提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核）的代码，并在论文中称这段被植入进程的代码为“shellcode”。
漏洞利用的核心就是利用程序漏洞去执行shellcode以便劫持进程的控制权。要达到该目的，需要通过代码植入的方式来完成，其目的是淹没返回地址，以便劫持进程的控制权，让程序跳转去执行shellcode。 
现在，“shellcode”已经表达的是广义上的植入进程的代码，而不是狭义上的仅仅用来获得shell的代码。Shellcode往往需要用汇编语言编写，并转换成二进制机器码，其内容和长度经常还会受到很多苛刻限制，故开发和调试的难度很高。
	植入代码之前需要做大量的调试工作，例如，弄清楚程序有几个输入点，这些输入将最终会当作哪个函数的第几个参数读入到内存的那一个区域，哪一个输入会造成栈溢出，在复制到栈区的时候对这些数据有没有额外的限制等。调试之后还要计算函数返回地址距离缓冲区的偏移并淹没之，选择指令的地址，最终制作出一个有攻击效果的“承载”着shellcode的输入字符串。 
2. 示例
已知漏洞
假设我们已知一个系统的注册机验证过程的漏洞，程序举例如下：
#include <stdio.h>
#include <windows.h>
#define REGCODE "12345678"
int verify (char * code)
{
	int flag;
	char buffer[44];
	flag=strcmp(REGCODE, code);
	strcpy(buffer, code);
	return flag; 
}
假设其主程序启动时候要校验注册码：
void main()
{
	int vFlag=0;
	char regcode[1024];
	FILE *fp;
	LoadLibrary("user32.dll");
	if (!(fp=fopen("reg.txt","rw+")))
		exit(0); 
	fscanf(fp,"%s", regcode);
	vFlag=verify(regcode);
	if (vFlag)
		printf("wrong regcode!");
	else
		printf("passed!"); 
	fclose(fp);
}
Verify函数的缓冲区为44个字节，对应的栈帧状态如下图所示：