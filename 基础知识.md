---
title: 基础知识
---

标签：漏洞利用与渗透测试

---

# 前言

## 病毒

计算机病毒 `Computer Virus` 能自行执行、能自我复制。

蠕虫病毒 `worm` 利用网络进行复制和传播，传染途径是通过网络和电子邮件。

| 类别 | 复制| 传染 | 
|-----|-----|-----|
|普通病毒| 需要传播受感染的驻留文件来进行复制 | 传染能力主要是针对计算机内的文件系统而言|
|蠕虫| 不使用驻留文件即可在系统之间进行自我复制 |传染目标是互联网内的所有计算机 |

木马 `Trojan Horse` 表面上是有用的软件、实际目的却是危害计算机安全并导致严重破坏的计算机程序。基于**远程控制**的黑客工具，隐蔽性、非授权性、欺骗性(宣称是良性的，但事实上是恶意的)。

木马不具传染性，不能像病毒那样复制自身，也不刻意去感染其他文件，它主要通过将自身伪装起来，吸引用户下载执行。

## 渗透测试

渗透测试是通过模拟恶意黑客的攻击方法，来评估计算机网络系统安全的一种评估方法。

- 黑箱测试
    `Zero-Knowledge Testing`，渗透者完全处于对系统一无所知的状态，通常这类型测试，最初的信息获取来自于DNS、Web、Email及各种公开对外的服务器。

- 白盒测试
    测试者可以通过正常渠道向被测单位取得各种资料，包括网络拓扑、员工资料甚至网站或其它程序的代码片断，也能够与单位员工进行沟通。这类测试目的是模拟企业内部雇员的越权操作。

- 隐秘测试
    被测单位仅有极少数人知晓测试的存在，有效地检验单位中的信息安全事件监控、响应、恢复做得是否到位。

## 设置Vmware Workstation

只说一下网络连接。

vmnet1 是 host-only，也就是说，选择用 vmnet1  虚拟机可以与真实系统相互共享文件，但是虚拟机无法访问外部互联网。

vmnet8是NAT，即网络地址转换，虚拟机和真实系统可以相互共享，都能访问外部互联网。而且虚拟机是借用真实系统的IP上网的，不会受到IP-MAC绑定的限制。 

## kali

---

# 基础知识

## 堆栈基础

---

### 内存

- 代码区，存储二进制机器代码
- 数据区，存储全局变量
- 堆区，动态内存分配和回收
- 栈区，动态存储函数之间的调用关系

---

### 函数调用

C语言中，每个栈帧对应着一个未运行完的函数。栈帧中保存函数返回地址和局部变量。从逻辑上讲，栈帧就是一个函数执行的环境：函数参数、函数的局部变量、函数返回地址等。

```
    fun_B(){...}
    fun_A(){...fun_B();...}
    int main(){...fun_A();...}
```

![](https://github.com/braveghz/Exploitation-and-Penetration-Testing/blob/master/images/函数调用.png)

- 在`main`函数调用`func_A`的时候，首先在自己的栈帧中压入函数返回地址，然后为`func_A`创建新栈帧并压入系统栈。
- 在`func_A`调用`func_B`的时候，同样先在自己的栈帧中压入函数返回地址，然后为`func_B`创建新栈帧并压入系统栈。
- 在`func_B`返回时，`func_B`的栈帧被弹出系统栈，`func_A`栈帧中的返回地址被露在栈顶，处理器按照这个返回地址重新跳到`func_A`代码区中执行。
- 在`func_A`返回时，`func_A`的栈帧被弹出系统栈，`main`函数栈帧中的返回地址被露在栈顶，此时处理器按照这个返回地址跳到`main`函数代码区中执行。

---

### 寄存器与栈帧

- ESP：栈指针寄存器（`extended stack pointer`），其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。
- EBP：基址指针寄存器（`extended base pointer`），其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。

    ![](https://github.com/braveghz/Exploitation-and-Penetration-Testing/blob/master/images/espebp.png)

- 函数栈帧：`ESP`和`EBP`之间的内存空间为当前栈帧，`EBP`标识了当前栈帧的底部，`ESP`标识了当前栈帧的顶部。在函数栈帧中，一般包含以下几类重要信息：
    - 局部变量
    - 栈帧状态值：保存前栈帧的底部，前栈帧的顶部可以通过堆栈平衡计算得到，用于在本帧被弹出后恢复出上一个栈帧。
	- 函数返回地址：函数调用前的指令位置，以便在函数返回时能够恢复到函数被调用前的代码区中继续执行指令。

- EIP：指令寄存器（`extended instruction pointer`），其内存放着一个指针，该指针永远指向下一条等待执行的指令地址。可以说如果控制了`EIP`寄存器的内容，就控制了进程——我们让`EIP`指向哪里，CPU就会去执行哪里的指令。 

函数调用大致包括以下几个步骤：
- 参数入栈：将参数从右向左依次压入系统栈中。
- 返回地址入栈：将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行。
- 代码区跳转：处理器从当前代码区跳转到被调用函数的入口处。
- 栈帧调整：具体包括。
    - 保存当前栈帧状态值，已备后面恢复本栈帧时使用（`EBP`入栈）。
    - 将当前栈帧切换到新栈帧（将`ESP`值装入`EBP`，更新栈帧底部）。

**注意**：栈区地址由高到低，即栈底地址处于高地址，栈顶地址处于低地址。 

---

### 汇编

---

#### 四类寄存器：

- 4个数据寄存器(`EAX`、`EBX`、`ECX`和`EDX`)
- 2个变址寄存器(`ESI`和`EDI`) 2个指针寄存器(`ESP`和`EBP`)
- 6个段寄存器(`ES`、`CS`、`SS`、`DS`、`FS`和`GS`)
- 1个指令指针寄存器(`EIP`) 1个标志寄存器(`EFlags`)

1. 数据寄存器

    数据寄存器主要保存操作数和运算结果等。32位CPU有4个32位通用寄存器`EAX`、`EBX`、`ECX`和`EDX`。低16位寄存器为：`AX`、`BX`、`CX`和`DX`。对低16位数据的存取，不会影响高16位的数据。

    16位寄存器可分为8位寄存器(`AX：AH-AL`、`BX：BH-BL`、`CX：CH-CL`、`DX：DH-DL`)，每个寄存器可独立存取。

    - `EAX`通常称为累加器(`Accumulator`)，可用于乘、 除、输入/输出等操作，还通常用于存储函数的返回值。
    - `EBX`称为基地址寄存器(`Base Register`)，可作为存储器指针来使用。
    - `ECX`称为计数寄存器(`Count Register`)。在循环和字符串操作时，用它来控制循环次数。
    - `EDX`称为数据寄存器(`Data Register`)。在进行乘、除运算时，可作为默认的操作数参与运算，也可用于存放`I/O`的端口地址。

2. 变址寄存器

    `ESI`和`EDI`。低16位对应`SI`和`DI`，对低16位数据的存取，不影响高16位的数据。

    `ESI`通常在内存操作指令中作为**源地址指针**使用，`EDI`在内存操作指令中作为**目的地址指针**使用。

3. 指针寄存器

    `EBP`、`ESP`称为指针寄存器(`Pointer Register`)，主要用于存放堆栈内 存储单元 的偏移量。指针寄存器不可分割成8位寄存器。也可存储算术逻辑运算的操作数和运算结果。

    `EBP`、`ESP`主要用于访问堆栈内的存储单元，并且规定：
    - `EBP`为基指针(`Base Pointer`)寄存器，通过减去一定的偏移值来访问栈中元素；
    - `ESP`为堆栈指针(`Stack Pointer`)寄存器，始终指向栈顶。 
4. 段寄存器

    段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址=段寄存器的值+一个偏移量。

    `CPU`内部的段寄存器：
    - `CS`——代码段寄存器(`Code Segment Register`)，其值为代码段的段值；
    - `DS`——数据段寄存器(`Data Segment Register`)，其值为数据段的段值；
    - `ES`——附加段寄存器(`Extra Segment Register`)，其值为附加数据段的段值；
    - `SS`——堆栈段寄存器(`Stack Segment Register`)，其值为堆栈段的段值；
    - `FS`
    - `GS`
5. 指令指针寄存器

    32位 `EIP`,存放下次将要执行的指令在代码段的偏移量。

---

#### 主要指令

- 数据传送指令集
    - `MOV`: 源操作数 --> 目的操作数
    - `XCHG`: 交换两个操作数的数据
    - `PUSH`,`POP`: 把操作数 压入 或 取出 堆栈 
- 算数运算指令
    - `ADD`：加法指令 
    - `SUB`:减法指令
    - `INC`, `DEC`: 把`OP`的值加一或减一
    - `NEG`: `OP`的符号反相(取二进制补码)
    - `MUL`: 乘法指令
    - `DIV`:除法指令
- 位运算指令集
    - `AND`,`OR`,`XOR`,`NOT`: 位运算(与/或/异或/非)
    - `SHR`,`SHL`: 移位指令
    - `ROR`,`ROL`,`RCR`,`RCL`: 循环移位指令
- 程序流程控制指令集
    - `CMP`: 比较`OP1`与`OP2`的值
    - `JMP`: 跳往指定地址执行
    - `LOOP`: 循环指令集
    - `CALL`,`RET`: 子程序调用,返回指令
    - `INT`,`IRET`: 中断调用及返回指令。在执行`INT`时,`CPU`会自动将标志寄存器的值入栈,在执行`IRET`时则会将堆栈中的标志值弹回寄存器
- 条件转移命令
    `JXX`: 当特定条件成立则跳往指定地址执行
    常用：
    - `Z`：为0转移
    - `G`：大于则转移
    - `L`：小于则转移
    - `E`：等于则转移
    - `N`：取相反条件 
- 字符串操作指令集
    - `MOVSB`,`MOVSW`,`MOVSD`: 字符串传送指令
    - `CMPSB`,`CMPSW`,`CMPSD`: 字符串比较指令
    - `SCASB`,`SCASW`: 字符串搜索指令

---

#### 举例
```
int add(int x,int y)
{
    z=x+y;
    return z;
}
void main()
{
	n=add(1,3);
}
```

关注 `main` 函数中调用 `add` 函数所发生的栈帧变化：

- 函数调用前：参数入栈
    ```
    00411415  push        3    
    00411417  push        1  
    ```  
    参数入栈，此时栈区状态为：

    ![](https://github.com/braveghz/Exploitation-and-Penetration-Testing/blob/master/images/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A81.PNG)

- 函数调用时：返回地址入栈
    ```
    00411419  call        add (411096h)
    ```
    函数调用`call`完成：
    - 压入当前指令在内存中的位置，即保存返回地址；
    - 跳转到函数入口处。
    此时栈区状态为：

    ![](https://github.com/braveghz/Exploitation-and-Penetration-Testing/blob/master/images/函数调用2.png)

- 栈帧切换
    ```
    004113A0  push       ebp；       //将EBP的值入栈  
    004113A1  mov        ebp,esp；   //将ESP的值赋值给EBP 
    004113A3  sub        esp, 0CCh； //将ESP抬高，得到栈大小为0CCH
    ```
    上面三行汇编代码完成了栈帧切换，即保存了主函数栈帧的EBP的值，通过改变EBP和ESP寄存器的值，为add函数分配了栈帧空间。 此时栈区状态为：

    ![](https://github.com/braveghz/Exploitation-and-Penetration-Testing/blob/master/images/函数调用3.png)

- 函数状态保存

    ```
    004113A9  push        ebx；      //保存现场  ebx作为内存偏移指针使用
    004113AA  push        esi；      //保存现场  esi是源地址指针寄存器
    004113AB  push        edi；      //保存现场  edi是目的地址指针寄存器
    004113AC  lea         edi,[ebp-0CCh] ；      //将当前栈顶地址装入EDI
    004113B2  mov         ecx,33h；              //设置计数器数值，即将ECX寄存器赋值为33h
    004113B7  mov         eax,0CCCCCCCCh；       //向寄存器EAX赋值
    004113BC  rep stos    dword ptr es:[edi]；   //循环将栈区数据都初始化为CCh
    ```

    其中：
    `rep`指令的目的是重复其上面的指令.`ECX`的值是重复的次数. 
    `STOS`指令的作用是将`eax`中的值拷贝到`ES:EDI`指向的地址.  
    
- 执行函数体

    ```
	    int z=0;
    004113BE  mov         dword ptr [z],0 ；     //将z初始化为0
        z=x+y;
    004113C5  mov         eax,dword ptr [x]；    //将寄存器EAX的值设置为形参x的值
    004113C8  add         eax,dword ptr [y] ；   //将寄存器EAX累加形参y的值
    004113CB  mov         dword ptr [z],eax；    //将EAX的值复制给z
        return z;
    004113CE  mov         eax,dword ptr [z]；    //将z的值存储到EAX寄存器中
    ```

    此时函数栈帧情况如下：

    ![](https://github.com/braveghz/Exploitation-and-Penetration-Testing/blob/master/images/函数调用4.png)

- 恢复状态

    函数调用完毕，函数的返回值将存储在EAX寄存器中。之后将恢复栈状态到`main`函数：

    ```
    004113D1  pop         edi  ；    //恢复寄存器值
    004113D2  pop         esi  ；    //恢复寄存器值
    004113D3  pop         ebx  ；    //恢复寄存器值
    004113D4  mov         esp,ebp ； //恢复寄存器值
    004113D6  pop         ebp  ；    //恢复寄存器值
    004113D7  ret            ；      //根据返回地址恢复EIP值，相当于pop EIP
    ```

---

## 二进制文件

### PE文件

源代码 通过 编译 和 连接 后形成可执行文件。`PE`（`Portable Executable`）是`Win32`平台下可执行文件遵守的数据格式。常见的可执行文件（如`*.exe`文件和`*.dll`文件）都是`PE`文件。

`PE`文件格式把可执行文件分成若干个 数据节（`section`），不同资源被存放在不同的节中。一个典型的`PE`文件中包含的节如下：

- `.text`  存放二进制机器代码
- `.data`  初始化的数据块，如宏定义、全局变量、静态变量等。
- `.idata`  可执行文件所使用的动态链接库等外来函数与文件的信息。
- `.rsrc`   存放程序的资源，如图标、菜单等。

除此以外，还可能出现的节包括`.reloc`、`.edata`、`.tls`、`.rdata`等。

标准`PE`文件节信息往往是大致相同的。使用`Microsoft Visual C++`中的编译指示符`#pragma data_seg()`可以把代码中的任意部分编译到`PE`的任意节中，节名也可以自己定义，如果可执行文件经过了加壳处理，`PE`的节信息就会变得非常古怪。

加壳 的全称是**可执行程序资源压缩**。加壳过的程序可以直接运行，但是不能查看源代码。要经过脱壳才可以查看源代码。

**加壳** 其实是利用特殊算法，对`EXE`、`DLL`文件里的代码、资源等进行压缩、加密,类似`WINZIP` 的效果，只不过这个压缩之后的文件可以独立运行，解压过程完全隐蔽，都在内存中完成。它们附加在原程序上通过`Windows加载器`载入内存后，先于原始程序执行，得到控制权，执行过程中对原始程序进行解密、还原，还原完成后再把控制权交还给原始程序，执行原来的代码部分。加上外壳后，原始程序代码在磁盘文件中一般是以加密后的形式存在的，只在执行时在内存中还原，这样就可以比较有效地防止破解者对程序文件的非法修改，同时也可以防止程序被静态反编译。

加壳工具通常分为压缩壳和加密壳两类。
- 压缩壳,减小软件体积大小,加密保护不是重点。
- 加密壳种类比较多，不同的壳侧重点不同，一些壳单纯保护程序，另一些壳提供额外的功能，如提供注册机制、使用次数、时间限制等。

### 虚拟内存

`Windows`的内存分为：物理内存和虚拟内存。通常，在用户模式下，用调试器看到的内存地址都是虚拟内存。

用户编程序时使用的地址称为 `虚拟地址` 或 `逻辑地址` ，其对应的存储空间称为 `虚拟内存` 或 `逻辑地址空间`。

计算机物理内存的访问地址则称为 `实地址` 或 `物理地址` ，其对应的存储空间称为 `物理存储空间` 或 `主存空间` 。

程序进行 虚地址 到 实地址 转换的过程称为**程序的再定位**。


### PE文件与虚拟内存的映射

- 文件偏移地址（`File Offset`）
    数据在`PE`文件中的地址叫文件偏移地址，这是文件在磁盘上存放时相对于文件开头的偏移。
- 装载基址（`Image Base`）
    `PE`装入内存时的基地址。默认情况下，`EXE`文件在内存中的基地址是`0x00400000`，`DLL`文件是`0x10000000`。
- 虚拟内存地址（`Virtual Address`，` VA`）
	PE文件中的指令被装入内存后的地址。
- 相对虚拟地址（`Relative Virtual Address`， `RVA`）
	相对虚拟地址是内存地址相对于映射基址的偏移量。

虚拟内存地址、映射基址、相对虚拟内存地址三者之间有如下关系：`VA = Image Base + RVA`


---

`OllyDBG` 和 `IDA Pro`的使用另说。