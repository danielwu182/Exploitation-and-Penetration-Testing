10.1基础知识
1. HTTP协议 
超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标示符（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。 
关于HTTP协议的详细内容请参考RFC2616。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、URL、协议版本、以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，响应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。 
2. HTML
“超文本”就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素。超文本标记语言Html的结构包括“头”部分（英语：Head）、和“主体”部分（英语：Body），其中“头”部提供关于网页的信息，“主体”部分提供网页的具体内容。
一个网页对应多个HTML文件，超文本标记语言文件以.htm（磁盘操作系统DOS限制的外语缩写）为扩展名或.html（外语缩写）为扩展名。可以使用任何能够生成TXT类型源文件的文本编辑器来产生超文本标记语言文件，只用修改文件后缀即可。
标准的超文本标记语言文件都具有一个基本的整体结构，标记一般都是成对出现（部分标记除外例如：<br/>），即超文本标记语言文件的开头与结尾标志和超文本标记语言的头部与实体两大部分。有三个双标记符用于页面整体结构的确认。
标记符<html>，说明该文件是用超文本标记语言（本标签的中文全称）来描述的，它是文件的开头;而</html>，则表示该文件的结尾，它们是超文本标记语言文件的开始标记和结尾标记。
< head></head>：这2个标记符分别表示头部信息的开始和结尾。头部中包含的标记是页面的标题、序言、说明等内容，它本身不作为内容来显示，但影响网页显示的效果。头部中最常用的标记符是标题标记符和meta标记符，其中标题标记符用于定义网页的标题，它的内容显示在网页窗口的标题栏中，网页标题可被浏览器用作书签和收藏清单。 
以下表格列出了 HTML head 元素：
标签	描述
<head>	定义了文档的信息
<title>	定义了文档的标题
<base>	定义了页面链接标签的默认链接地址
<link>	定义了一个文档和外部资源之间的关系
<meta>	定义了HTML文档中的元数据
<script>	定义了客户端的脚本文件
<style>	定义了HTML文档的样式文件
主体内容  
<body></body>：网页中显示的实际内容均包含在这2个正文标记符之间。正文标记符又称为实体标记。
3. COOKIE
Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。
Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等，服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。
Cookie用途：服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是Cookies的功用。另一个重要应用场合是“购物车”之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入Cookies，以便在最后付款时提取信息。
生存周期：Cookie可以保持登录信息到用户下次与服务器的会话，换句话说，下次访问同一网站时，用户会发现不必输入用户名和密码就已经登录了（当然，不排除用户手工删除Cookie）。而还有一些Cookie在用户退出会话的时候就被删除了，这样可以有效保护个人隐私。
    跨站Cookie：实际上，Cookie中保存的用户名、密码等个人敏感信息通常经过加密，很难将其反向破解。但这并不意味着绝对安全，黑客可通过木马病毒盗取用户浏览器Cookie，直接通过偷取的Cookie骗取网站信任。可以看出，木马病毒入侵用户电脑是导致用户个人信息泄露的一大元凶。
自1993年Cookie诞生以来，其就拥有专属性原则，即A网站存放在Cookie中的用户信息，B网站是没有权限直接获取的。但是，一些第三方广告联盟的代码使用范围很广。这就造成用户在A网站搜索了一个关键字，用户继续访问B网站，由于B网站也使用了同一家的第三方广告代码，这个代码可以从Cookie中获取用户在A网站的搜索行为，进而展示更精准的推广广告。比如搜索“糖尿病”等关键词，再访问其联盟网站，页面会立刻出现糖尿病治疗广告。如果并未事先告之，经用户同意，此做法有对隐私构成侵犯的嫌疑。这个还处在灰色地带。
因此，跨站Cookie恰恰就是用户隐私泄露的罪魁祸首，所以限制网站使用跨站Cookie，给用户提供禁止跟踪功能选项已成为当务之急。据了解，IE、Chrome、360、搜狗等浏览器均可以快速清除用户浏览器网页的Cookie信息。但从整体的隐私安全保护环境来看，安全软件仍然存在着巨大的防护缺口。所以安全软件也可以并且有必要提供定期清理网站Cookie，并监测跨站Cookie使用的功能，保护用户隐私安全。
4. Javascript
JavaScript一种直译式脚本语言，它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。
JavaScript是一种属于网络的脚本语言，已经被广泛用于Web应用开发，常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的。
Javascript脚本语言同其他语言一样，有它自身的基本数据类型，表达式和算术运算符及程序的基本程序框架。Javascript提供了四种基本的数据类型和两种特殊数据类型用来处理数据和文字。而变量提供存放信息的地方，表达式则可以完成较复杂的信息处理。
日常用途：嵌入动态文本于HTML页面、对浏览器事件做出响应、读写HTML元素、在数据被提交到服务器之前验证数据、检测访客的浏览器信息、控制cookies，包括创建和修改等。  
示例：
点击右键显示“你好”，点击左键显示禁止复制 
<html>
<head>
<title></title>
<script type="text/javascript">
function MyClick() {
if (event.button ==1) {
alert("你好");
}
elseif (event.button ==2) {
alert("禁止复制");
}
else {
setTimeout("close();", 2000); 
}
}
function close() {
window.opener =null;
window.close();
}
</script>
</head>
<body onmouseup="MyClick()">
<br />
</body>
</html>
10.2WEB编程示例
WEB编程语言，分为WEB静态语言和WEB动态语言，WEB静态语言就是通常所见到的超文本标记语言（标准通用标记语言下的一个应用），WEB动态语言主要是ASP、PHP、JAVASCRIPT、JAVA、CGI等计算机脚本语言编写出来的执行灵活的互联网网页程序。
1. WEB服务环境安装 
PHPnow是Win32下绿色免费的Apache + PHP + MySQL 环境套件包。简易安装、快速搭建支持虚拟主机的 PHP 环境。附带 PnCp.cmd控制面板，帮助你快速配置你的套件，使用非常方便。
PHPnow 是绿色的，解压后执行 Setup.cmd 初始化，即可得到一个 PHP + MySQL 环境。然后就可以直接安装 Discuz!, PHPWind, DeDe, WordPress 等程序。 
安装完后目录如下：

点击PnCp.cmd，如下：

选择序号20，即可启动PHPnow。
打开网页，访问http://127.0.0.1如下：

点击phpMyAdmin，将进入数据库管理界面，可以自行创建数据库、表以及录入数据等：

2. 第一个php程序 
使用工具Dreamweaver，来编辑产生第一个静态网页，该网页命名为login.htm，存储到PHPnow\htdocs下。
注：htdocs是PHPnow的web应用的根目录。
所编辑的login.htm代码如下：
<html>
<body>
<form id="form1" name="form1" method="post" action="loginok.php">
  <table width="900" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td height="20">姓名</td>
      <td height="20"><label>
        <input name="username" type="text" id="username" />
      </label></td>
    </tr>
    <tr>
      <td height="20">口令</td>
      <td height="20"><label>
        <input name="pwd" type="password" id="pwd" />
      </label></td>
    </tr>
    <tr>
      <td height="20">&nbsp;</td>
      <td height="20"><label>
        <input type="submit" name="Submit" value="提交" />
      </label></td>
    </tr>
  </table>
</form>
</body>
</html>
在上面的页面中，定义了一个form表单。表单是一个包含表单元素的区域。表单区域里包含了两个文本框（<input>）、一个确认按钮(submit) 。确认按钮的作用是当用户单击确认按钮时，表单的内容会被传送到另一个文件。而表单的动作属性(action)定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。
在上面的表单中，定义了接受表单输入的处理文件为“loginok.php”，而method属性指定了与服务器进行信息交互的方法为POST。
Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET、POST、PUT、DELETE就对应着对这个资源的查，改，增，删4个操作。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息，早期的系统由于不支持DELETE，因此PUT和DELETE用的较少。
具体的，POST和GET的区别如下： 
GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&相连，如：login.action?name=sean&password=123。 
POST把提交的数据则放置在是HTTP包的包体中。POST的安全性要比GET的安全性高。这里的安全不仅仅是通过URL就可以作数据修改，还包含更多的安全含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为登录页面有可能被浏览器缓存、其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了；除此之外，使用GET提交数据还可能会造成跨站请求伪造攻击(CSRF，Cross-site request forgery)。
处理提交输入的第一个php文件代码如下：
<?php 
 $username = $_POST['username'];
 $pwd = $_POST['pwd'];
 $SQLStr = "SELECT * FROM userinfo where username='$username' and pwd='$pwd'"; 
 echo $SQLStr ; 
?>
     实验：搭建环境，将表单的输入改为GET，php的程序也改为GET，看看变化在哪里？

3. 连接数据库
将上述第一个程序进行改进，使其达到对对输入的用户名和密码进行认证的目的。
在myDB库中，有一个表userinfo，包含两个字段，即username和pwd，则程序改动如下：
<?php
 $conn=mysql_connect("localhost", "root", "123456");  //连接数据库
 $username = $_POST['username'];
 $pwd = $_POST['pwd'];
 $SQLStr = "SELECT * FROM userinfo where username='$username' and pwd='$pwd'"; 
 echo $SQLStr ;
 $result=mysql_db_query("MyDB", $SQLStr, $conn); //执行数据库SQL语句
 // 获取查询结果 
 if ($row=mysql_fetch_array($result))//通过循环读取数据内容   
 	  echo "<br>OK<br>";
  else 
 	  echo "<br>false<br>";
    // 释放资源
    mysql_free_result($result);
    // 关闭连接
    mysql_close($conn);  
?>
如果登陆成功，则显示OK，否则，显示false。
数据库的连接分为几步：
连接数据库：$conn=mysql_connect("localhost", "root", "123456");
执行SQL操作：$result=mysql_db_query("MyDB", $SQLStr, $conn);
关闭连接：mysql_free_result($result); mysql_close($conn);  
4. 查询数据
   数据库的操作主要依赖于SQL语句，查询数据并显示的一个例子如下：
<?php
 $conn=mysql_connect("localhost", "root", "123456"); 
 $SQLStr = "SELECT * FROM userinfo ";  
 echo $SQLStr ;
 $result=mysql_db_query("MyDB", $SQLStr, $conn);
 // 获取查询结果 
 if ($row=mysql_fetch_array($result))//通过循环读取数据内容  
 {
 	  echo "<br>.... OK ....   表内内容：<br>";
 	   // 定位到第一条记录
    mysql_data_seek($result, 0);
    // 循环取出记录
    while ($row=mysql_fetch_row($result))
    { 
      for ($i=0; $i<mysql_num_fields($result); $i++ )
      { 
        echo $row[$i];
        echo "   |   ";
      }
      echo "<br>";
    }
 } else { 
 	  echo "<br>false<br>";
 }
    // 释放资源
    mysql_free_result($result);
    // 关闭连接
    mysql_close($conn);  
?>

5. 创建cookie
Cookie和session都可以暂时保存在多个页面中使用的变量，但是它们有本质的差别。
cookie存放在客户端浏览器中，session保存在服务器上。它们之间的联系是session ID一般保存在cookie中。
Cookie工作原理：当客户访问某个网站时，在PHP中可以使用setcookie函数生成一个cookie，系统经处理把这个cookie发送到客户端并保存在c:\Documents and Settings\用户名\Cookies目录下。Cookie是HTTP标头的一部分，因此setcookie函数必须在任何内容送到浏览器之前调用。当客户再次访问该网站时，浏览器会自动把c:\Documents and Settings\用户名\Cookies目录下与该站点对应的cookie发送到服务器，服务器则把从客户端传来的cookie将自动地转化成一个PHP变量。
必须在任何其他输出发送前对 cookie 进行赋值，而赋值函数则为setcookie。如果成功，则该函数返回 true，否则返回 false。
setcookie(name, value, expire, path, domain, secure)
name 必需。规定 cookie 的名称。
value 必需。规定 cookie 的值。
expire 可选。规定 cookie 的有效期。
path 可选。规定 cookie 的服务器路径。
domain 可选。规定 cookie 的域名。
secure 可选。规定是否通过安全的 HTTPS 连接来传输 cookie。
可以通过 $HTTP_COOKIE_VARS["user"] 或 $_COOKIE["user"] 来访问name指定的 cookie 的值。 
<?php
 $conn=mysql_connect("localhost", "root", "123456");  
 $username = $_POST['username'];
 $pwd = $_POST['pwd'];
 $SQLStr = "SELECT * FROM userinfo where username='$username' and pwd='$pwd'"; 
 echo $SQLStr ;
 $result=mysql_db_query("MyDB", $SQLStr, $conn);
 // 获取查询结果 
 if ($row=mysql_fetch_array($result))//通过循环读取数据内容  
 {
 	  setcookie("uname",$username);
 	  echo "<br>OK<br>";
 	  echo $_COOKIE["uname"]; 
 } else { 
 	  echo "<br>false<br>";
 }
      
    // 释放资源
    mysql_free_result($result);
    // 关闭连接
    mysql_close($conn);  
?>
创建一个页面，使用该cookie。所使用的是内存COOKIE，即没有设定COOKIE值的expires参数，也就是没有设置COOKIE的失效时间情况下，这个COOKIE在关闭浏览器后将失效，并且不会保存在本地。
另外一种是本地保存COOKIE，也就是设置了expires参数，COOKIE的值指定了失效时间，那么这个COOKIE 会保存在本地，关闭浏览器后再访问网站，在COOKIE有效时间内所有的请求都会带上这个本地保存COOKIE。
<?php 
if ($_COOKIE["uname"]==null)
  echo "should cookie";
else
  echo "ok";
?>
    如果一个页面依赖于某个cookie，而cookie的值被泄露后，即使没有登录，也可能利用该cookie来访问该页面，这就是cookie在客户端不安全引发的后果。
10.3WEB安全威胁
在过去的十多年里，Internet技术以惊人的速度在快速发展，因特网在给人们带来革命性的信息沟通与协作平台的同时，各种恶意程序与黑客攻击也史无前例的增多，随着各种Web应用服务的普遍开展，再加上越来越多的服务朝向Web化的方向迈进，Web安全所面临的威胁也与日俱增。
根据2010年OWASP（开放Web软件安全项目—Open Web Application Security Project）发布的Web应用十大安全威胁排名，排在前十位的安全风险依次为：注入、跨站脚本、遭破坏的身份认证和会话管理、不安全的直接对象引用、伪造跨站请求、安全配置错误、不安全的加密存储、没有限制的URL访问、传输层保护不足和未验证的重定向和转发。注入、跨站脚本和跨站请求伪造将在第十一章介绍，下面依次介绍其它7个Web安全威胁。
1. 遭破坏的身份认证和会话管理
（1）基本概念
和2010年相比，2013年OWASP的十大安全威胁排名中，“遭破坏的认证和会话管理”排名已经超过了“跨站脚本”，成为仅次于“注入”的排名第二的威胁。“遭破坏的认证和会话管理”是指攻击者窃听了用户访问HTTP时的用户名和密码，或者是用户的会话，从而得到sessionID，进而冒充用户进行HTTP访问的过程。
由于HTTP本身是无状态的，HTTP的每次访问请求都要带有个人凭证，SessionID是用户访问请求的凭证。sessionID本身很容易在网络上被嗅探到，所以攻击者往往通过监听sessionID来实现进一步的攻击，这就是这种安全风险居高不下的重要原因，但这种形式的攻击主要针对身份认证和会话。
在安全领域中，认证（Authentication）和授权（Authorization）的功能不相同。认证的目的在于确定“你是谁”，即根据不同用户的凭证来确定用户的身份，而授权的目的是确定“你可以干什么”，即通过认证后确定用户的权限有哪些。最常见的身份认证方式就是通过用户名与密码进行登录。认证就是验证凭证的过程，如果只有一个凭证被用于认证，则称为单因素认证；如果有两个或多个凭证被用于认证，则称为双因素认证或多因素认证。一般来说，多因素认证的安全强度要高于单因素认证。
（2）密码的安全性
密码是最常见的一种认证手段，持有正确密码的人被认为是可信的。使用密码进行认证的优点是成本低，认证过程实现简单；缺点是密码认证是一种比较弱的安全手段，因而存在被猜解的可能。  
不要使用用户的公开数据信息或是与个人隐私相关的数据信息作为密码，例如个人姓名拼音、身份证号、昵称、电话号码、生日等作为密码。这些资料一般情况下都可以很容易从互联网上获得。
目前黑客们常用的破解密码手段，不是暴力破解，而是使用一些弱口令去尝试进行字典攻击破解，比如123456，admin等，同时猜解用户名，直到发现使用这些弱口令的账户为止。由于用户名往往是公开的信息，攻击者可以收集一份用户名的字典，这种攻击成本很低，然而效果却很好。密码的保存也有一些需要注意的地方，例如，密码必须使用不可逆的加密算法或者是单向散列函数算法进行加密后存储到数据库中。这可以最大程度地保证密码的私密性。因为在这种情况下，无论是网站的管理员还是成功入侵网站的攻击者都无法从数据库中直接获取密码的明文。
（3）用户的认证必须通过加密信道进行传输
在用户登录时，在用户输入用户名和密码后一般通过POST的方法进行传输，认证信息可通过不安全的HTTP传递，也可通过加密的HTTPS传递。有些网站在登录页面显示的是HTTPS，而事实上却是用HTTP。检测是否使用HTTPS的最简单方法就是使用网络嗅探工具，如通过SnifferPro或Ethereal嗅探数据包来判断是否加密。
下面用OWASP的WebScrab截取的一些信息来做样例分析。
假设登陆页面要求用户输入用户名和密码，然后有一个“提交”按钮，那么在WebScrab中可以得到如下的请求数据：
POST http://www.example.com/login HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 5.2; rv:16) Gecko/20100101 Firefox/16.0
Accept: text/xml,application/xml,application/xhtml+xml
Accept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: http://www.example.com/index.jsp
Cookie:
JSESSIONID=LVrRRQQXgwyWpW7QMnS49vtW1rEdqn98CGlkP4jTvVCGdyPkmn3S!
Content-Type: application/x-www-form-urlencoded
Content-length: 64
delegated_service=218&User=test&Pass=test&Submit=SUBMIT
在上面的数据中，可以看到，POST方法通过HTTP协议把数据发送到http://www.example.com/login，然而由于传送的数据没有进行加密，恶意用户通过监听网络就很容易得到用户名test和密码test。
再看下一个用HTTPS协议的例子，请求的头数据如下：
POST https://www.example.com:443/login.do HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:16) Gecko/20100101 Firefox/16.0
Accept: text/xml,application/xml,application/xhtml+xml,text/html
Accept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: http://www.example.com/homepage.do
Cookie: SERVTIMSESSIONID=s2JyLkvDJ9ZhX3yr5BJeRFLkdphH0QNSJ3VQB6pLhjkW6F
Content-Type: application/x-www-form-urlencoded
Content-length: 45
User=test&Pass=test&portal=ExamplePortal
如上所示，请求通过HTTPS引向了https://www.example.com:443/login.do，如果看Referer的值，就发现是从HTTP http://www.example.com/homepage.do过来的。在这种情况下，浏览器窗口中并不会告知现在使用的安全连接，而事实上却是在使用HTTPS安全连接。在HTTPS协议下，上述协议的内容都是处于加密状态的，所以用户名和口令是无法看到的。上面的消息只是为了显示这个请求而进行了解析，实际内容是加密的。
在上面的例子中，如果用Get的方法，那么所输入的用户名和密码将会以明文的方式显示在URL中。
如果利用Get方法通过HTTPS来传递数据，其具体的情况可以看下面的数据：
GET https://www.example.com/success.html?user=test&pass=test HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:16) Gecko/20100101 Firefox/16.0
Accept: text/xml,application/xml,application/xhtml+xml,text/html
Accept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: https://www.example.com/form.html
从上面的例子可以看到，用户名和密码都以明文的方式在URL里存在，而不像上面的几个例子中都在消息体中，但是这并不是说攻击者就可以很容易看到这些信息，TLS/SSL是安全性很高的协议，整个HTTP 数据包是加密的，但仍然要注意这些用户名和密码在传输过程中会被存储在代理和服务器上，这也有可能会泄露用户信息。
（4）会话与认证
密码与证书等认证手段，一般仅用于登录过程。当登录完成后，不会每次浏览器请求访问页面时都使用密码进行认证。因此，当认证成功后，就使用一个对用户透明的凭证SessionID进行认证。当用户登录完成后，服务器端就会创建一个新的会话（Session）。会话中会保存用户的状态和相关信息。服务器端维护所有在线用户的Session，此时的认证，只需要知道哪个用户在浏览当前的页面即可。为使服务器确定应该使用哪个Session，用户的浏览器要把当前用户持有的SessionID传给服务器。最常见的做法就是把SessionID加密后保存在Cookie中传给服务器。
SessionID一旦在生命周期内被窃取，就等于账户失窃。由于SessionID是用户登录持有的认证凭证，因此黑客不需要再想办法通过用户名和密码进行登录，而是直接使用窃取的SessionID与服务器进行交互。会话劫持就是一种窃取用户SessionID后，使用该SessionID登录进入目标账户的攻击方法，此时攻击者实际上是利用了目标账户的有效Session。如果SessionID是被保存在Cookie中，则这种攻击被称为Cookie劫持。
 SessionID除了可以保存在Cookie中，还可以作为请求的一个参数保持在URL中传输。这种情况在手机操作系统中较为常见，由于很多手机浏览器暂不支持Cookie，所以只能将SessionID作为URL的一个参数传输以进行认证。手机浏览器在发送请求时，一旦SessionID泄漏，将直接导致信息外泄。例如，某些WEB邮箱的SessionID在Referer中泄漏，就等同于邮箱账号密码被盗。对于这种情况的防范在于生成SessionID时，需要保证足够的随机性。
（5）会话保持攻击
Session是有生命周期的，当用户长时间未活动后，或者用户点击退出后，服务器将销毁Session。如果攻击者窃取了用户的Session，并一直保持一个有效的Session（比如间隔性地刷新页面，以使服务器认为这个用户仍然在活动），而服务器对于活动的Session也一直不销毁，攻击者就能通过此有效Session一直使用用户的账户，即成为一个永久的“后门”，这就是会话保持攻击。
下面一段代码，能保持Session。
<script>
var url=”http://bbs.example.com/index.php?sid=1”;
Window.setInterval(“keepsid()”,6000);
Fuction keepsid()
{
   Document.getElementById(“a1”).src=url+”&time=”+Math.random();
}
</script>
<iframe id=”a1” src=””></iframe>
其原理就是不停地刷新页面，以保持Session不过期。
针对这种Session保持攻击，常见的做法是在一定的时间后，强制销毁Session。这个时间可以是从用户登陆的时间开始算起，设定一个阈值，比如登陆1天后就强制Session过期。但是强制销毁Session可能会影响到一些正常的用户，还可以使用的方法是当用户客户端发生变化时，系统要求用户重新登陆，比如用户的IP、用户代理等信息发生改变时，就可以强制销毁当前的Session，并要求用户重新登陆。
2. 不安全的直接对象引用
（1）不安全的直接对象引用的概念
不安全的直接对象引用在OWASP TOP 10排名中居于第四位，它可以被归于访问控制一类威胁，但是由于其危害程度颇为严重，所以被单独分割出来进行讨论。
Direct Object Reference简称DOR，即直接对象引用，是指WEB应用程序的开发人员将一些不应公开的对象引用直接暴露给用户，使得用户可以通过更改URL等操作直接引用对象。
所谓不安全的直接对象引用就是指一个用户通过更改URL等操作可以成功访问到未被授权的内容。比如一个网站上的用户通过更改URL可以访问到其他用户的私密信息和数据等。
（2）不安全的直接对象引用的原理
下面是OWASP官方所给出的一个关于不安全的直接对象引用的示例。
String query=”SELECT * FROM accts WHERE account=?”;
PreparedStatement pstmt=connection.prepareStatement(query, ...);
pstmt.setString(1,request.getParameter(“acct”));
ResultSet results=pstmt.executeQuery();
上面的代码中通过一个未被验证的用户账号来获取相关数据，在这样的情况下，攻击者可以通过在浏览器中简单修改“acct”参数的值发送到不同的用户账号来获取信息。因为代码并没有进行任何的验证，所以能够轻易的访问到其他用户的信息。
（3）不安全的直接对象引用的攻击步骤
不安全的直接对象引用攻击，主要包含下面两个步骤。
第一步，首先需要判断Web网站是否有泄漏直接对象引用给用户，如果在整个Web网站中未发现直接对象引用，则不存在此威胁。
第二步，通过更改URL等操作，尝试访问非授权的数据，如果Web网站没有进行访问控制，即可获取Web网站非授权数据。
（4）不安全的对象引用的防范措施
为了防止不安全的对象引用，需要尽量避免将私密的对象引用直接暴露给用户。在向用户提供访问之前，一定要进行认证和审查，实行严格的访问控制。
3. 安全配置错误
安全配置错误是Web应用系统常见的安全问题，在Web应用的各个层次都有可能出现安全配置错误，比如操作系统、Web服务器、应用程序服务器、数据库、应用程序等。
安全配置错误更多的需要网络管理人员配合开发人员的需要，尽可能的对Web应用系统的各个层次进行合理的配置。有各种各样的安全配置错误，比如，未能及时对各个层次的软件进行更新，默认的用户名密码没有及时修改，对于不必要的功能和服务没有及时的进行关闭甚至卸载，一些安全项配置不合理等都有可能导致Web应用系统被攻击。
为了防止安全配置错误，首先，必须及时将各个软件更新到最新状态。其次，采用安全的系统框架，对Web系统的各个组件进行分离。最后，考虑定时对Web系统进行扫描，以发现可能存在的配置错误。归根到底就是尽可能的将Web应用系统的各个方面都做好安全配置。
4. 不安全的加密存储
2012年，CSDN网站600万账户密码泄露事件等一系列类似事件，导致网络安全及用户个人隐私成为大众关心的焦点。CSDN事件之所以严重的主要原因，是因为CSDN网站采用明文方式来存储用户名和密码，使得用户的隐私被轻易的泄露。
所谓不安全的加密存储指的是Web应用系统没有对敏感性资料进行加密，或者采用的加密算法复杂度不高可以被轻易破解，或者加密所使用的密钥非常容易检测出来。归根到底就是所存储的内容能够轻易被攻击者解析从而产生安全威胁。
为了防止不安全的加密存储，对于所有的敏感性数据必须进行加密，且无法被轻易破解。保证加密密钥被妥善保管，攻击者不能轻易窃取，并准备密钥的定期更换。对于敏感存储内容必须进行严格的访问控制，只允许授权用户进行操作。
5. 没有限制的URL访问
通常URL访问限制主要是限制未授权用户访问某些链接，一般通过隐藏来实现保护这些链接。然而对于一个攻击者来说，在某些情况下有可能能够访问被隐藏了的链接，从而可以使用未被授权的功能。
为了防止一些未经授权的URL访问，可以对每一个页面加上适当的授权和认证机制。
对于每一个URL链接必须要配置一定的防护措施，包括：对于要隐藏的链接必须能限制非授权用户的访问；加强基于用户或者角色的访问控制；禁止访问一些私密的页面类型。
6. 传输层保护不足
Web应用系统一般部署在远端服务器上，客户端和服务器之间的请求和响应消息会在互联网上传输。攻击者利用嗅探方法就可以简单的截获网络上的数据，如果传输层上没有任何的保护措施，那么对于用户和Web应用系统都是非常危险的。
SSL协议可以实现Internet上数据传输的安全，通过利用数据加密技术，它可确保数据在网络上传输不会被截取或者窃听。
当传输层没有进行安全保护时，会遇到下面的安全威胁。
（1）会话劫持
HTTP是无状态协议，客户端和服务端并没有建立长连接。服务器为了识别用户连接，服务器会发送给客户端SessionID。如果传输层保护不足，攻击就可以通过嗅探的方法获取传输内容，提取SessionID，冒充受害者发送请求。
（2）中间人攻击
中间人攻击(Man-in-the-middle attack)，即MITM。HTTP连接的目标是Web服务器，如果传输层保护不足，攻击者可以担任中间人的角色，在用户和Web服务器之间截获数据并在两者之间进行转发，使用户和服务器之间的整个通信过程暴露在攻击者面前。
为了实现对传输层的安全保护，可以将所有的敏感页面采用SSL技术加密传输，将未采用SSL的请求转向SSL页面。同时，后台或者其他链接也应该使用SSL或者其他加密技术。在使用SSL协议时，需要确保数字证书的有效性。
7. 未验证的重定向及转发
重定向就是将网络请求从一个网址转移到其他网址。在Web应用系统中，重定向是非常常见的，并且通常重定向所指向的目的是通过用户输入参数得到的。如果没有经过验证，攻击者就能够将其他用户引导到特定的站点。转发与重定向略有不同，但在Web系统中同样也非常常见。总的来说，未经过验证的重定向将可能使用户被引导到钓鱼网站或者挂马网站等恶意站点，而未经过验证的转发将可能导致用户绕过验证和授权机制。
下面通过OWASP的示例来进行原理的介绍。
示例1：应用程序的一个”redirect.jsp”页面有一个参数“url”。攻击者构造一个恶意的URL,可把用户重定向到一个恶意站点evil.com，如下所示。
http://www.example.com/redirect.jsp?url=evil.com
示例2：应用程序使用转发功能在网站的不同部分之间转发请求。为了实现这个功能，程序的一些页面使用参数来表明用户应该被重定向到什么地方。在这种情况下，攻击者就可以构造URL以成功绕过应用程序的访问控制功能，从而使攻击者可以获得在正常情况下无法获得的管理功能。
http://www.example.com/boring.jsp?fwd=admin.jsp
为了防范未验证的重定向及转发，需要考虑以下几点防范措施：尽量避免使用重定向和转发；使用重定向和转发要避免通过参数获得地址；如果必须使用目标地址，必须校验地址，并加强授权和认证。
