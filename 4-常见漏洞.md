# 缓冲区溢出漏洞

## 基本概念

缓冲区 -- 一块连续的内存区域, 存放程序运行时 加载到内存的 代码和数据。

**缓冲区溢出** 指程序运行时，向固定大小的缓冲区写入超过其容量的数据，多余的数据会越过缓冲区的边界覆盖相邻内存空间，从而造成溢出。

缓冲区的大小是由用户输入的数据决定的，如果程序不对用户输入的超长数据作长度检查，同时用户又对程序进行了非法操作或者错误输入，就会造成缓冲区溢出。

**缓冲区溢出攻击** 是指发生缓冲区溢出时，溢出的数据会覆盖相邻内存空间的返回地址、函数指针、堆管理结构等合法数据，从而使程序运行失败、或者发生转向去执行其它程序代码、或者执行预先注入到内存缓冲区中的代码。缓冲区溢出后执行的代码，会以原有程序的身份权限运行。如果原有程序是以系统管理员身份运行，那么攻击者利用缓冲区溢出攻击后所执行的恶意程序，就能够获得系统控制权，进而执行其它非法操作。

**造成缓冲区溢出的根本原因** 是缺乏类型安全功能的程序设计语言（C、C++等）出于效率的考虑，部分函数不对数组边界条件和函数指针引用进行边界检查。例如，C 标准库中和字符串操作有关的函数，像 `strcpy`， `strcat`， `sprintf`， `gets`等函数中，数组和指针都没有自动边界检查。程序员开发时必须自己进行边界检查，防范数据溢出，否则所开发的程序就存在缓冲区溢出的安全隐患，而实际上这一行为往往被程序员忽略或者检查不充分。 

---

## 栈溢出漏洞

被调用的子函数中写入数据的长度，大于栈帧的基址到 `esp`之间预留的保存局部变量的空间时，就会发生栈溢出。要写入数据的填充方向是从低地址向高地址增长，多余的数据就会越过栈帧的基址，覆盖基址以上的地址空间。

1. 修改返回地址

    如果返回地址被覆盖，当覆盖后的地址是一个无效地址，则程序运行失败。如果覆盖返回地址的是恶意程序的入口地址，则源程序将转向去执行恶意程序。

    栈的存取采用先进后出，程序用它来保存函数调用时的有关信息，如函数参数、返回地址，函数中的非静态局部变量存放在栈中。举例：

    ```cpp
    void stack_overflow(char* argument)
    {
        char local[4];
        for (int i = 0; argument[i]; i++)
            local[i] = argument[i];
    }
    ```
    样例程序中，函数 `stack_overflow`被调用时堆栈布局如图

    ![](https://github.com/braveghz/Exploitation-and-Penetration-Testing/blob/master/images/栈溢出.PNG)

    图中 `local`是栈中保存局部变量的缓冲区，根据 `char local[4]`预先分配的大小为4个字节，当向local中写入超过4个字节的字符时，就会发生溢出。如用 `AAAABBBBCCCCDDDD`作为参数调用，当函数中的循环执行后，栈顶布局如图右侧。可以看出输入参数中 `CCCC`覆盖了返回地址，当 `stack_overflow`执行结束，根据栈中返回地址返回时，程序将转到地址 `CCCC`并执行此地址指向的程序，如果 `CCCC`地址为攻击代码的入口地址，就会调用攻击代码。

2. 修改临接变量

    如果返回临近变量的值，可能会更改程序执行流程。

    函数的局部变量在栈中一个挨着一个排列。如果这些局部变量中有数组之类的缓冲区，并且程序中存在数组越界的缺陷，那么越界的数组元素就有可能破坏栈中相邻变量的值，甚至破坏栈帧中所保存的 `EBP`值、返回地址等重要数据。

    举例：

    ```c
    #include <stdio.h>
    #include <iostream>
    #define PASSWORD "1234567"
    int verify_password(char * password)
    {
        int authenticated;
        char buffer[8];  
        authenticated = strcmp(password, PASSWORD);
        strcpy(buffer, password);
        return authenticated;
    }
    void main()
    {
        int valid_flag = 0;
        char password[1024];
        while(1)
        {
            printf("please input password:    ");
            scanf("%s", password);
            valid_flag = verify_password(password);
            if(valid_flag)
            printf ("incorrect password!\n\n");
            else{
            printf("Congratulation! You have passed the verification!\n");
            break;
            }
        }
    }
    ```
    在 `verify_password` 函数的栈帧中，局部变量 `int authenticated`恰好位于缓冲区 `char buffer[8]`的"下方"。

    `authenticated`为int类型，在内存中是一个 `DWORD`，占4个字节。所以，如果能够让 `buffer`数组越界，`buffer[8]`、 `buffer[9]`、 `buffer[10]`、 `buffer[11]`将写入相邻的变量 `authenticated`中。

    `authenticated` 变量的值来源于 `strcmp`函数的返回值，之后会返回给 `main`函数作为密码验证成功与否的标志变量：当 `authenticated`为 0 时，表示验证成功;反之，验证不成功。

    如果我们输入的密码超过了7个字符（注意：字符串截断符NULL将占用一个字节），则越界字符的 `ASCII`码会修改掉 `authenticated`的值。如果这段溢出数据恰好把 `authenticated`改为0，则程序流程将被改变。

---

3. 其它溢出漏洞

    1. 堆溢出

        堆 --内存空间中用于存放 动态数据 的区域。与栈不同的是，程序员自己完成 堆中变量的分配与释放，而 栈中变量空间的分配与释放由程序负责。
        
        堆空间是由低地址向高地址方向增长，而栈空间从高地址向低地址方向增长。

        `堆溢出` 是指在堆中发生的缓冲区溢出。

        堆内存分配- - 操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 `delete`语句才能正确释放内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

        **堆空间由低地址向高地址方向增长**

        ```c
        void heap_overflow()
        {
            char *buffer1,*buffer2;
            buffer1 = (char*)malloc(8);	//为buffer1在堆中分配8个字节
            char s[] = "AAAAAAAABBBBBBBBCCCCDDDD";
            memcpy(buffer1,s,24);		//向buffer1复制24个字节
            buffer2 = (char*)malloc(8);	//为buffer2在堆中分配8个字节
            free(buffer1);
            free(buffer2);
            return;
        }
        ```

        为buffer1分配内存后，堆内存布局如下图所示。

        ![](https://github.com/braveghz/Exploitation-and-Penetration-Testing/blob/master/images/堆溢出1.PNG)

        执行memcpy后堆内存布局如下图所示。

        ![](https://github.com/braveghz/Exploitation-and-Penetration-Testing/blob/master/images/堆溢出2.PNG)

        堆内存分配时会调用函数 `RtlAllocHeap`，该函数从空闲堆链上摘下一空闲堆块，它执行如下操作：

        ```
        mov dword ptr [edi], ecx
        mov dword ptr [ecx+4], edi
        ```

        其中 `ecx`为空闲可分配的堆区块的前指针， `edi`为该堆区块的后指针。
        然而，为 `buffer2`分配内存空间时，空闲块双链指针已经被 `memcpy`覆盖为 `CCCCDDDD`，也就是说 `RtlAllocHeap`执行上述操作时，`ecx`为 `CCCC`，`edi`为`DDDD`，这样指令 `mov dword ptr [edi], ecx` 就意味着将 `CCCC`写入 `[DDDD]=[0x44444444]`，从而实现了利用堆溢出向内存单元写入任意数据，实现改写内存中的关键数据，达到攻击的目的。

        堆溢出的触发类型有多种，以上样例仅是一种堆溢出的情况，相比于栈溢出，堆溢出的实现难度更大，而且往往要求进程在内存中具备特定的组织结构。然而，堆溢出攻击也已经成为缓冲区溢出攻击的主要方式之一，利用堆溢出可以有效绕过基于栈溢出的缓冲区溢出防范措施。

    2. 单字节溢出

        单字节溢出是指程序中的缓冲区仅能溢出一个字节。单字节溢出的原理通过下面的样例进行分析。
        ```
        void single_func(char *src)
        {
            char buf[256];
            int i;
            for(i = 0;i <= 256;i++)
                    buf[i] = src[i];	//拷贝257个字节到256个字节的缓冲区
        }
        ```
        缓冲区溢出一般是通过覆盖堆栈中的返回地址，使程序跳转到 `shellcode`或指定程序处执行。然而在一定条件下，当缓冲区只溢出一个字节时，单字节溢出也是可以利用的，但实际上利用难度较大。

---

# 格式化字符串漏洞

什么是格式化字符串

`print()` 、 `fprint()` 等 `*print()`系列的函数可以按照一定的格式将数据进行输出，举例：

```c
printf("My Name is:  %s" , "xxxx")
```
执行该函数后将返回字符串： `My Name is：xxxx`

该 `printf`函数的第一个参数就是 `格式化字符串`，它来告诉程序将数据以什么格式输出。

 `printf()`函数的一般形式为：`printf("format", 输出表列)`， `format`的结构为：`%[标志][输出最小宽度][.精度][长度]类型`，其中类型有以下常见的几种：
- `％d` 整型输出， `％ld` 长整型输出
- `％o` 以八进制数形式输出整数
- `％x` 以十六进制数形式输出整数
- `％u` 以十进制数输出 `unsigned`型数据
- `％c` 用来输出一个字符
- `％s` 用来输出一个字符串
- `％f` 用来输出实数，以小数形式输出

在控制了 `format` 参数之后结合 `printf()` 函数的特性就可以进行相应的攻击。

C 语言中的格式化函数（ `*printf`族函数，包括 `printf`， `fprintf`， `sprintf`， `snprintf`等）允许可变参数，它根据**传入的格式化字符串**获知**可变参数的个数和类型**，并依据格式化符号进行参数的输出。

如果调用这些函数时，给出了格式化符号串，但没有提供实际对应参数时，这些函数会**将格式化字符串后面的多个栈中的内容弹出作为参数，并根据格式化符号将其输出。** 

当格式化符号为 `%x`时以16进制的形式输出堆栈的内容，为 `%s`时则输出对应地址所指向的字符串。

```c
void formatstring_func1(char *buf)
{
    char mark[] = "ABCD";
    printf(buf);
}
```
调用时如果传入 `%x%x…%x`，则 `printf`会打印出堆栈中的内容，不断增加 `%x`的个数会逐渐显示堆栈中高地址的数据，从而导致堆栈中的数据泄漏。

更危险的是格式化符号 `%n`，它的作用是**将格式化函数输出字符串的长度，写入函数参数指定的位置**。

`%n`不向 `printf`传递格式化信息，而是 **令 `printf`把自己到 该点 已打出的字符总数 放到 相应变元指向的整形变量中**，比如

```c
printf("Jamsa%n", &first_count)
```
将向整型变量 `first_count `处写入整数5。

---

- 特性一： printf()函数的参数个数不固定

    可以利用这一特性进行越界数据的访问。先看一个正常的程序：

    ```c
    #include <stdio.h>
    int main(void)
    {
        int a=1,b=2,c=3;
        char buf[]="test";
        printf("%s %d %d %d\n",buf,a,b,c);
        return 0;
    }
    ```

    编译之后运行（`Release`模式）： `test 1 2 3` ，接下来我们增加一个 `printf()`的 `format`参数，改为：

    ```c
    printf("%s %d %d %d %x\n",buf,a,b，c)
    ```
    编译后运行（`Release`模式）：`test 1 2 3 c30000` 。为什么输出了一个 `c30000`？----在没有给出 `%x`的参数的时候，将自动将栈区参数的下一个地址作为参数输入。

   
- 特性二：利用%n格式符写入数据

    ```c
    #include <stdio.h>
    main()
    {
        int num=66666666;
        printf("Before: num = %d\n", num);
        printf("%d%n\n", num, &num);
        printf("After: num = %d\n", num); 
    }
    ```
    可以发现我们用 `%n`成功修改了 `num`的值： 
    ```
        Before: num = 66666666
        66666666
        After: num = 8
    ```
   
- 特性三：自定义打印字符串宽度 

    在格式符中间加上一个十进制整数来表示输出的最少位数，若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。
    ```c
    #include <stdio.h>
    main()
    {
        int num=66666666; 
        printf("Before: num = %d\n", num);
        printf("%.100d%n\n", num, &num);
        printf("After: num = %d\n", num);
    }
    ```
    运行后可以看到，我们的 `num`值被改为了 `100`。
---

# 整数溢出漏洞

- 存储溢出
- 运算溢出
- 符号问题

```c
char* integer_overflow(int* data,unsigned int len)
{
	unsigned int size = len + 1;
	char *buffer = (char*)malloc(size);
	if(!buffer)
        return NULL;
	memcpy(buffer,data,len);
	buffer[len]='\0';
    return buffer;
} 
```
该函数将用户输入的数据拷贝到新的缓冲区，并在最后写入结尾符0。如果攻击者将 `0xFFFFFFFF` 作为参数传入 `len`，当计算 `size`时会发生整数溢出，`malloc`会分配大小为 0 的内存块，后面执行 `memcpy`时会发生堆溢出。

---

# SQL注入漏洞

```sql
strKeyword = Request["keyword"];
sqlQuery   = "SELECT * FROM Aritcles WHERE Keywords LIKE '%' + strKeyword + '%' ";
```
按照用户提交的关键字 `keyword`，对软件连接数据库中的文件进行搜索，找出所有包含用户关键字的文章。

假设此时，我们提交 `hack`，这时，`hack`会传递给 `keyword`关键变量。`keyword` 获得数据 `hack`后被赋值给 `strKeyword`变量，然后 `strKeyword`变量被放入查询语句。此时的查询语句表现为：

```sql
SELECT * FROM Aritcles WHERE Keywords LIKE '% hack %' 
```
意思就是从数据库 `Aritcles`表中查询出所有包含 `hack`这个关键字的文章。

注意哦.....`hack`这个词是由我们提交的，因此可以对其随意修改。于是，我们修改一下 `hack`，把它变成 ` hack': DROP TABLE Aritcles: --`。

首先 ` hack': DROP TABLE Aritcles; --` 被赋值给 `strKeyword`变量， `strKeyword`变量解码后进入查询语句，这个时候的查询语句被换成了：

```sql
SELECT * FROM Aritcles WHERE Keywords LIKE '%hack'; DROP TABLE Aritcles; --%
```
查询 -- 删除Aritcles表
	
常常出现在论坛程序中进行用户认证的程序：

```sql
admin1 = trim(request("name"))
password1 = trim(request("password"))
Set rs = Server.CreatObject("ADODB.Recordset")
sql = "select * from userlogin where name = '"&admin1&"' and password = '"&password1&"'"
rs.Open sql, conn, 1, 1
if rs.eof and rs.bof then
    response.write"<SCRIPT language = JAVAScript>alert('用户名或密码不正确！')"
    response.write"javascript:history.go(-1)</SCRIPT>"
    response.end
else  # 设置Session对象，重定向 default.asp
    session("name") = rs("name")
    session("password") = rs("password")
    response.Redirect("default.asp")
end if
```

假设 `guest` -- 密码123456
```sql
sql = "select * from userlogin where name = 'guest' and password = '123456'"
```

用户名 `' or 1 = ' 1` 密码`' or 1 = ' 1`
and then you are ok! why?
```sql
sql = "select * from userlogin where name = " or 1 = '1' and password = " or 1 = '1'"
```
查询语句永远为真---绕过用户认证

---

# 其他漏洞

## 数组越界漏洞

1. 读取恶意构造的输入数据
2. 用输入数据计算数组访问索引
3. 对数组进行读/写操作

## Bypass漏洞

假设软件只允许管理员登录，不允许其他人登录。可是，你发现利用某种方法，即使你不知道管理员的密码，你也能够登录该软件，这个时候，你就发现了一个"登录限制绕过漏洞"。
假设又一个软件限制你访问某些特定的文件。可是，你发现利用修改文件属性的方法可以使得你能够访问特定的被加密文件，这个时候，你绕过了软件的限制，就又发现了一个"文件限制绕过漏洞"。

总的来说，Bypass漏洞是一个大类，它包含了很多小类，这些小类有一个共同的特点，就是这些出现问题的软件在使用上都存在对用户使用的限制，而Bypass漏洞就可以绕过软件的限制，使得软件的限制形同虚设。

Windows2000系统的输入法漏洞 -- 这个漏洞可以不知道别人系统密码的情况下，成功地访问到系统内部的所有文件与数据信息。Windows2000系统的输入法漏洞允许用户在不知道系统密码的情况下，在输入用户名的窗口中调出"帮助"程序，借助"帮助"程序的"调至URL"功能，访问到系统的任意一个文件。

例如杀毒软件存在Bypass漏洞，病毒文件绕过被杀毒软件发现的安全保护机制，用户会放心运行该病毒文件-----
















































---
更多详情请见原书。《漏洞利用与渗透测试基础》
**友情链接**：[原书购买地址]( https://detail.tmall.com/item.htm?spm=0.0.0.0.tZriNw&id=545402369740
)