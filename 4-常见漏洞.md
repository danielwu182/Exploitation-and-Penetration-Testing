---
title: 4-常见漏洞
tags:
- 漏洞利用与渗透测试
---

# 缓冲区溢出漏洞

## 基本概念
缓冲区 -- 一块连续的内存区域, 存放程序运行时 加载到内存的 代码和数据。

**缓冲区溢出**指程序运行时，向固定大小的缓冲区写入超过其容量的数据，多余的数据会越过缓冲区的边界覆盖相邻内存空间，从而造成溢出。

缓冲区的大小是由用户输入的数据决定的，如果程序不对用户输入的超长数据作长度检查，同时用户又对程序进行了非法操作或者错误输入，就会造成缓冲区溢出。

**缓冲区溢出攻击** 是指发生缓冲区溢出时，溢出的数据会覆盖相邻内存空间的返回地址、函数指针、堆管理结构等合法数据，从而使程序运行失败、或者发生转向去执行其它程序代码、或者执行预先注入到内存缓冲区中的代码。缓冲区溢出后执行的代码，会以原有程序的身份权限运行。如果原有程序是以系统管理员身份运行，那么攻击者利用缓冲区溢出攻击后所执行的恶意程序，就能够获得系统控制权，进而执行其它非法操作。

**造成缓冲区溢出的根本原因** 是缺乏类型安全功能的程序设计语言（C、C++等）出于效率的考虑，部分函数不对数组边界条件和函数指针引用进行边界检查。例如，C 标准库中和字符串操作有关的函数，像 `strcpy`， `strcat`， `sprintf`， `gets`等函数中，数组和指针都没有自动边界检查。程序员开发时必须自己进行边界检查，防范数据溢出，否则所开发的程序就存在缓冲区溢出的安全隐患，而实际上这一行为往往被程序员忽略或者检查不充分。 

---

## 栈溢出漏洞
被调用的子函数中写入数据的长度，大于栈帧的基址到 `esp`之间预留的保存局部变量的空间时，就会发生栈溢出。要写入数据的填充方向是从低地址向高地址增长，多余的数据就会越过栈帧的基址，覆盖基址以上的地址空间。

1. 修改返回地址
如果返回地址被覆盖，当覆盖后的地址是一个无效地址，则程序运行失败。如果覆盖返回地址的是恶意程序的入口地址，则源程序将转向去执行恶意程序。

栈的存取采用先进后出，程序用它来保存函数调用时的有关信息，如函数参数、返回地址，函数中的非静态局部变量存放在栈中。
举例：
```cpp
void stack_overflow(char* argument)
{
	char local[4];
    for (int i = 0; argument[i]; i++)
         local[i] = argument[i];
}
```
样例程序中，函数 `stack_overflow`被调用时堆栈布局如图所示
![](images/栈溢出.png)

图中 `local`是栈中保存局部变量的缓冲区，根据 `char local[4]`预先分配的大小为4个字节，当向local中写入超过4个字节的字符时，就会发生溢出。如用 `AAAABBBBCCCCDDDD`作为参数调用，当函数中的循环执行后，栈顶布局如图右侧。可以看出输入参数中 `CCCC`覆盖了返回地址，当 `stack_overflow`执行结束，根据栈中返回地址返回时，程序将转到地址 `CCCC`并执行此地址指向的程序，如果 `CCCC`地址为攻击代码的入口地址，就会调用攻击代码。

2. 修改临接变量
如果返回临近变量的值，可能会更改程序执行流程。

函数的局部变量在栈中一个挨着一个排列。如果这些局部变量中有数组之类的缓冲区，并且程序中存在数组越界的缺陷，那么越界的数组元素就有可能破坏栈中相邻变量的值，甚至破坏栈帧中所保存的 `EBP`值、返回地址等重要数据。

举例：
```c
#include <stdio.h>
#include <iostream>
#define PASSWORD "1234567"
int verify_password(char * password)
{
    int authenticated;
    char buffer[8];  
    authenticated = strcmp(password, PASSWORD);
    strcpy(buffer, password);
    return authenticated;
}
void main()
{
    int valid_flag = 0;
    char password[1024];
    while(1)
	{
        printf("please input password:    ");
        scanf("%s", password);
        valid_flag = verify_password(password);
        if(valid_flag)
           printf ("incorrect password!\n\n");
        else{
           printf("Congratulation! You have passed the verification!\n");
           break;
		}
	}
}
```
在 `verify_password` 函数的栈帧中，局部变量 `int authenticated`恰好位于缓冲区 `char buffer[8]`的“下方”。

`authenticated`为int类型，在内存中是一个 `DWORD`，占4个字节。所以，如果能够让 `buffer`数组越界，`buffer[8]`、 `buffer[9]`、 `buffer[10]`、 `buffer[11]`将写入相邻的变量 `authenticated`中。

`authenticated` 变量的值来源于 `strcmp`函数的返回值，之后会返回给 `main`函数作为密码验证成功与否的标志变量：当 `authenticated`为 0 时，表示验证成功;反之，验证不成功。

如果我们输入的密码超过了7个字符（注意：字符串截断符NULL将占用一个字节），则越界字符的 `ASCII`码会修改掉 `authenticated`的值。如果这段溢出数据恰好把 `authenticated`改为0，则程序流程将被改变。

---

3. 其它溢出漏洞

    1. 堆溢出
    堆- -内存空间中用于存放 动态数据 的区域。与栈不同的是，程序员自己完成 堆中变量的分配与释放，而 栈中变量空间的分配与释放由程序负责。
    
    堆空间是由低地址向高地址方向增长，而栈空间从高地址向低地址方向增长。

    `堆溢出` 是指在堆中发生的缓冲区溢出。

    堆内存分配- - 操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 `delete`语句才能正确释放内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

    **堆空间由低地址向高地址方向增长**

    ```cpp
    void heap_overflow()
    {
        char *buffer1,*buffer2;
        buffer1 = (char*)malloc(8);	//为buffer1在堆中分配8个字节
        char s[] = “AAAAAAAABBBBBBBBCCCCDDDD”;
        memcpy(buffer1,s,24);		//向buffer1复制24个字节
        buffer2 = (char*)malloc(8);	//为buffer2在堆中分配8个字节
        free(buffer1);
        free(buffer2);
        return;
    }
    ```

    为buffer1分配内存后，堆内存布局如下图所示。
    ![](images/堆溢出1.png)

    执行memcpy后堆内存布局如下图所示。
    ![](images/堆溢出2.png)

    堆内存分配时会调用函数 `RtlAllocHeap`，该函数从空闲堆链上摘下一空闲堆块，它执行如下操作：
    ```
    mov dword ptr [edi], ecx
    mov dword ptr [ecx+4], edi
    ```
    其中 `ecx`为空闲可分配的堆区块的前指针， `edi`为该堆区块的后指针。
    然而，为 `buffer2`分配内存空间时，空闲块双链指针已经被 `memcpy`覆盖为 `CCCCDDDD`，也就是说 `RtlAllocHeap`执行上述操作时，`ecx`为 `CCCC`，`edi`为`DDDD`，这样指令 `mov dword ptr [edi], ecx` 就意味着将 `CCCC`写入 `[DDDD]=[0x44444444]`，从而实现了利用堆溢出向内存单元写入任意数据，实现改写内存中的关键数据，达到攻击的目的。

    堆溢出的触发类型有多种，以上样例仅是一种堆溢出的情况，相比于栈溢出，堆溢出的实现难度更大，而且往往要求进程在内存中具备特定的组织结构。然而，堆溢出攻击也已经成为缓冲区溢出攻击的主要方式之一，利用堆溢出可以有效绕过基于栈溢出的缓冲区溢出防范措施。

    2. 单字节溢出
    单字节溢出是指程序中的缓冲区仅能溢出一个字节。单字节溢出的原理通过下面的样例进行分析。
    ```
    void single_func(char *src)
    {
        char buf[256];
        int i;
        for(i = 0;i <= 256;i++)
                buf[i] = src[i];	//拷贝257个字节到256个字节的缓冲区
    }
    ```
    缓冲区溢出一般是通过覆盖堆栈中的返回地址，使程序跳转到 `shellcode`或指定程序处执行。然而在一定条件下，当缓冲区只溢出一个字节时，单字节溢出也是可以利用的，但实际上利用难度较大。

---

# 格式化字符串漏洞

什么是格式化字符串
`print()` 、 `fprint()` 等 `*print()`系列的函数可以按照一定的格式将数据进行输出，举例：
```c
printf("My Name is:  %s" , "xxxx")
```
执行该函数后将返回字符串： `My Name is：xxxx`
该 `printf`函数的第一个参数就是 `格式化字符串，它来告诉程序将数据以什么格式输出`。
 `printf()`函数的一般形式为：`printf("format", 输出表列)`， `format`的结构为：`%[标志][输出最小宽度][.精度][长度]类型`，其中类型有以下常见的几种：
- `％d` 整型输出， `％ld` 长整型输出
- `％o` 以八进制数形式输出整数
- `％x` 以十六进制数形式输出整数
- `％u` 以十进制数输出 `unsigned`型数据
- `％c` 用来输出一个字符
- `％s` 用来输出一个字符串
- `％f` 用来输出实数，以小数形式输出
在控制了 `format` 参数之后结合 `printf()` 函数的特性就可以进行相应的攻击。

C 语言中的格式化函数（ `*printf`族函数，包括 `printf`， `fprintf`， `sprintf`， `snprintf`等）允许可变参数，它根据**传入的格式化字符串**获知**可变参数的个数和类型**，并依据格式化符号进行参数的输出。

如果调用这些函数时，给出了格式化符号串，但没有提供实际对应参数时，这些函数会**将格式化字符串后面的多个栈中的内容弹出作为参数，并根据格式化符号将其输出。** 
当格式化符号为 `%x`时以16进制的形式输出堆栈的内容，为 `%s`时则输出对应地址所指向的字符串。

例
```c
void formatstring_func1(char *buf)
{
    char mark[] = “ABCD”;
    printf(buf);
}
``
调用时如果传入 `%x%x…%x`，则 `printf`会打印出堆栈中的内容，不断增加 `%x`的个数会逐渐显示堆栈中高地址的数据，从而导致堆栈中的数据泄漏。

更危险的是格式化符号 `%n`，它的作用是**将格式化函数输出字符串的长度，写入函数参数指定的位置**。
`%n`不向 `printf`传递格式化信息，而是 **令 `printf`把自己到 该点 已打出的字符总数 放到 相应变元指向的整形变量中**，比如 
```c
printf(“Jamsa%n”, &first_count)
```
将向整型变量 `first_count `处写入整数5。


---
没懂哦
再如： 
```c
int formatstring_func2(int argc,char *argv[])
{
    char buffer[100];
    sprintf(buffer,argv[1]);
}
```
`Sprintf` 函数的作用是把格式化的数据写入某个字符串缓冲区。
函数原型为：
```c
int sprintf( char *buffer, const char *format, [ argument] … );
```
如果调用这段程序时用 `aaaabbbbcc%n` 作为命令行参数，则最终数值 `10` 就会被写入地址为 `0x61616161` 的内存单元。因为这段程序执行时，它首先将 `aaaabbbbcc` 写入 `buffer`，然后从堆栈中取下一个参数，并将其当作整数指针使用。在这个例子中，由于调用 `sprintf`时没有传入下一个参数，因而 `buffer`中的前四个字节被当作参数，这样已输出字串的长度 `10`就被写入内存地址 `0x61616161` 处。通过这种格式化字符串的利用方式，可以实现向任意内存写入任意数值。

---

- 特性一： printf()函数的参数个数不固定
可以利用这一特性进行越界数据的访问。先看一个正常的程序：
```c
#include <stdio.h>
int main(void)
{
    int a=1,b=2,c=3;
    char buf[]="test";
    printf("%s %d %d %d\n",buf,a,b,c);
    return 0;
}
```
编译之后运行（`Release`模式）： `test 1 2 3`
接下来我们增加一个 `printf()`的 `format`参数，改为：
```c
printf("%s %d %d %d %x\n",buf,a,b，c)
```
编译后运行（`Release`模式）：`test 1 2 3 c30000`
为什么输出了一个 `c30000`？
在没有给出 `%x`的参数的时候，将自动将栈区参数的下一个地址作为参数输入。

如果进一步增加 `%x`呢？比如：
```c
printf("%s %d %d %d %x %x %x %x %x %x %x %x\n",buf,a,b,c)
```
会不会继续读取剩余内存？
要读取任意内存怎么办？对于如下的程序：
```c
#include <stdio.h>
int main(int argc, char *argv[])
{
    char str[200];
    fgets(str,200,stdin);
    printf(str);
    return 0;
}
```
编译后运行（`Release模式`）并输入：`AAAA%x%x%x%x`
我们成功读到了`AAAA：AAAA18FE84BB40603041414141`（ `0x41`就是 `ASCII`的字母 A 的值）。
如果将 `AAAA`换成地址，第4个 `%x`，换成 `%s`的读取参数指定的地址上的数据呢？是不是就可以读取任意内存地址的数据了？
比如我们输入：`AAAA%x%x%x%s`
这样就构造了去获取 `0x41414141`地址上的数据的输入。

- 特性二：利用%n格式符写入数据
```c
#include <stdio.h>
main()
{
  int num=66666666;
  printf("Before: num = %d\n", num);
  printf("%d%n\n", num, &num);
  printf("After: num = %d\n", num); 
}
```
可以发现我们用 `%n`成功修改了 `num`的值： 
```
Before: num = 66666666
66666666
After: num = 8
```
现在我们已经知道可以用构造的格式化字符串去访问栈内的数据，并且可以利用 `%n`向内存中写入值，那我们是不是可以修改某一个函数的返回地址从而控制程序执行流程呢？ `%n`的作用只是将前面打印的字符串长度写入到内存中，而我们想要写入的是一个地址，而且这个地址是很大的。这时候我们就需要用到 `printf()`函数的第三个特性来配合完成地址的写入。 
# 特性三：自定义打印字符串宽度 
在格式符中间加上一个十进制整数来表示输出的最少位数，若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。
```c
#include <stdio.h>
main()
{
  int num=66666666; 
  printf("Before: num = %d\n", num);
  printf("%.100d%n\n", num, &num);
  printf("After: num = %d\n", num);
}
```
运行后可以看到，我们的 `num`值被改为了 `100`。
这样的话，我们就清楚如何去覆盖一个地址了吧？
比如说我们要把 `0x8048000`这个地址写入内存，我们要做的就是把该地址对应的10进制 `134512640`作为格式符控制宽度即可。
如果需要修改的数据是相当大的数值时，我们可以使用 `%02333d`这种形式。在打印数值右侧用0补齐不足位数的方式来补齐足。
```c
printf("%0134512640d%n\n", num, &num);
printf("After: num = %x\n", num);
```
运行后可以看到，我们的 `num` 被成功修改为`8048000`。

接下来思考：就是针对如下程序，通过构造输入完成任意地址的改写，将变量flag的值改为2000，使程序输出good！
```c
#include <stdio.h>
int main(int argc, char *argv[])
{
    char str[200];
	int flag = 0;
    int *p = &flag;  
    fgets(str,200,stdin);
    printf(str); 
    if(flag == 2000)
    {
        printf("good!!\n");
    } 
    return 0;
}
```
注意：（1）观察Release模式下，该程序的变化，能否实现输出good的功能？（2）如果不能通过代码调试，那么逻辑上，应该的堆栈结构是什么样子，构造什么样子的字符串可以实现覆盖flag变量的值？

---

# 整数溢出漏洞

根据溢出原理的不同，整数溢出可以分为以下三类：
- 存储溢出
    存储溢出是使用另外的数据类型来存储整型数造成的。
- 运算溢出
- 符号问题
    整型数可分为有符号整型数和无符号整型数两种。

整数溢出的样例
```c
char* integer_overflow(int* data,unsigned int len)
{
	unsigned int size = len + 1;
	char *buffer = (char*)malloc(size);
	if(!buffer)
        return NULL;
	memcpy(buffer,data,len);
	buffer[len]=’\0’;
    return buffer;
} 
```
该函数将用户输入的数据拷贝到新的缓冲区，并在最后写入结尾符0。如果攻击者将 `0xFFFFFFFF` 作为参数传入 `len`，当计算 `size`时会发生整数溢出，`malloc`会分配大小为 0 的内存块，后面执行 `memcpy`时会发生堆溢出。
整数溢出一般不能被单独利用，而是用来绕过目标程序中的条件检测，进而实现其他攻击，正如上面的例子，利用整数溢出引发缓冲区溢出。 

---

# SQL注入漏洞
```sql
strKeyword = Request[“keyword”];
sqlQuery   = “SELECT * FROM Aritcles WHERE Keywords LIKE ‘%’ + strKeyword + ‘%’ ”;
```
按照用户提交的关键字 `keyword`，对软件连接数据库中的文件进行搜索，找出所有包含用户关键字的文章。

假设此时，我们提交 `hack`，这时，`hack`会传递给 `keyword`关键变量。`keyword` 获得数据 `hack`后被赋值给 `strKeyword`变量，然后 `strKeyword`变量被放入查询语句
此时的查询语句表现为：
```sql
SELECT * FROM Aritcles WHERE Keywords LIKE ‘% hack %’ 
```
意思就是从数据库 `Aritcles`表中查询出所有包含 `hack`这个关键字的文章。

注意哦.....`hack`这个词是由我们提交的，因此可以对其随意修改。于是，我们修改一下 `hack`，把它变成 ` hack’: DROP TABLE Aritcles: --`。
	
现在来看看会怎样处理这个外部关键字数据。

首先
` hack’: DROP TABLE Aritcles; --` 被赋值给 `strKeyword`变量， `strKeyword`变量解码后进入查询语句，这个时候的查询语句被换成了：

```sql
SELECT * FROM Aritcles WHERE Keywords LIKE ‘%hack%’; DROP TABLE Aritcles; --
```
将“SELECT * FROM Aritcles WHERE Keywords LIKE ‘%hack’; DROP TABLE Aritcles; --%’”以中间的分号为标志分成两个部分，先看第1部分“SELECT * FROM Aritcles WHERE Keywords LIKE ‘%hack’”，这是一个完整的数据库查询语句，查询的结果就是所有包含hack关键字的文章。
	
接着看第2部分，由于该软件使用的数据库是微软的SQL SERVER数据库，该数据库支持多命令语句执行，这些数据库操作的命令语句都是由分号分隔开，然后依次执行的。这样，第2部分语句中刚开始就是一个分号，这样就将这句查询语句隔成了两个段，第1段就是第1部分，后面的一段就是第2部分，只要第2部分的命令语句合法，那么数据库SQL SERVER也会将其完全执行。这里的“DROP TABLE Aritcles; --%’”是一个完全合法的命令语句，其最后面的分号的作用是将本段命令与下一段命令隔开，形成一个完整的命令语句，而最后“--”符号则是SQL SERVER数据库特有的注释标识，数据库不执行任何命令。现在可以看到，当数据库SQL SERVER通过软件接收到这段查询语句后，会先按照查询条件找出hack的文章，然后就会去执行一个删除Aritcles表的数据库命令，这是软件没有料想到的，因为软件本来的目的只是简单地从数据库中按照关键字来查询文章，但是由于我们修改了传递给它的关键变量值，因而导致了软件数据库中的Aritcles表被非法删除。
	
像这样，通过控制传递给软件数据库操作语句的关键变量来获得恶意控制软件数据库、获取有用的信息或者制造恶意破坏的，甚至是控制用户计算机系统的漏洞，就称之为“SQL注入漏洞”。
SQL注入漏洞完全是利用了将包含了某种目的的SQL语句，通过关键变量插入到软件中正常的数据库操作语句中。软件一旦发生注入漏洞，就会引发一系列的安全隐患。
SQL注入漏洞是不分语言的。无论是用什么样的语言开发软件，只要涉及对数据库的操作，都可能存在SQL注入漏洞。虽然有时会因为编写语言的要求，或者软件设置环境的不同，导致SQL注入漏洞很难被常用的方法利用，但是总可以找到突破的方法。
	
下面以网站程序为例，看一看SQL注入漏洞的另外一种危害。
我们都知道对于任何一个网站来说，数据库存储着网站所有的信息，Web应用程序完全是凭借数据库中的信息进行正常运行的。你一定访问过一些大型论坛，作为一个论坛程序，最关键的一个部分是对用户的合法性进行判断，也就是看访问它的用户是不是一个注册的用户。这个时候，论坛会要求访问它的用户输入用户名及密码，然后会根据用户输入的信息查询数据库，判断数据库中是否存在该用户，并且检查该用户的密码是不是与输入的密码一致，如果一致则承认用户是合法的，否则将给予非法提示。
下面来看一段常常出现在论坛程序中进行用户认证的程序：
(1)admin1 = trim(request(“name”))
(2)password1 = trim(request(“password”))
(3)Set rs = Server.CreatObject(“ADODB.Recordset”)
(4)sql = “select * from userlogin where name = ‘”&admin1&”’ and password = ‘”&password1&”’”
(5)rs.Open sql, conn, 1, 1
(6)if rs.eof and rs.bof then
(7)response.write”<SCRIPT language = JAVAScript>alert(‘用户名或密码不正确！’)”
(8)response.write”javascript:history.go(-1)</SCRIPT>”
(9)response.end
(10)else
(11)session(“name”) = rs(“name”)
(12)session(“password”) = rs(“password”)
(13)response.Redirect(“default.asp”)
(14)end if
	这段程序的第1和第2行分别通过Request对象获得用户名以及密码，第3行是建立一个数据库操作集对象，第4行就是将用户名以及密码同时作为查询条件放入到userlogin表中进行查询，第5到第1行根据查询结果，如果不存在该用户信息则弹出一个“用户名或密码不正确”的警告窗口，否则就设置Session对象，然后重定向网页到首页文件default.asp。
	假设数据库中有一个用户名为“guest”，其密码是“123456”， 这个时候只要用户在论坛的登录表单中，在用户名以及密码的地方相应地输入“guest”以及“123456”，在论坛进行用户认证时，认证代码中的第4行则变为：sql = “select * from userlogin where name = ‘guest’ and password = ‘123456’”，这是一个合法的查询语句，所以用户能够正常登录论坛。反之，如果用户输入的用户名错误或者即使用户名正确但是密码错误，这样都登录不了论坛。
	看起来这是一个比较严格的认证代码，但是我现在告诉你一种不需要知道任何用户信息就能登录论坛的方式。现在重新回到登录论坛的地方，在用户名的地方输入“’ or 1 = ‘ 1”密码也填写成“’ or 1 = ‘ 1”，然后单击“登录”提交这个表单，你会发现你竟然成为了合法用户，论坛没有显示任何报警信息。这一切是怎么发生的呢？问题其实就出在论坛的认证代码上面，当我们提交表单后，代码通过Request对象获得提交的用户名以及密码后，直接将这些数据放入到第4行的查询语句中，现在这个查询语句就成了这个样子：sql = “select * from userlogin where name = “ or 1 = ‘1’ and password = “ or 1 = ‘1’”。我们只要先看一个地方：“1 = ‘1’”，这段代码的意思我想不用多说，这绝对是一个永远为真的代码，注意在这段代码的前面还有一个“or”，这代表着“1 = ‘1’”是作为一个条件选择语句放入数据库查询的，这样无论查询语句中的用户名以及密码是否正确，都会因为or后面的“1 = ‘1’”代码，而导致查询语句的返回值永远为真，这样就使得我们绕过了这个看似“严格”的用户认证，获得了以合法用户登录论坛的权限。
	其实很多软件与网站程序一样，都具有用户登录这样一个机制，如果软件的登录功能存在上面网站程序一样的SQL注入漏洞，那么软件的登录功能就如同虚设，任何人都可以不需要密码账户而直接登录进入软件，从而访问到秘密的数据信息。
	由此可见，SQL注入漏洞是一种危害性极大的漏洞，对于存储有大量用户数据信息的软件来说，可以说是“致命”的。

---

# 其他漏洞

## 数组越界漏洞
数组越界漏洞是目前一种主要的软件漏洞，它是由于不正确的数组访问造成。攻击者通过精心构造超出数组范围的索引值，就能够对任意内存地址进行读写操作。
数组越界漏洞触发时在执行路径上有以下特征：
（1）读取恶意构造的输入数据
通过调用C/C++运行时的库函数fread，或者操作系统的ReadFile、recv、recvfrom等API函数，读取用户输入的恶意输入数据。往往指定读取数目的参数是常量，一般为1字节、2字节或者4字节。
（2）用输入数据计算数组访问索引
对读取的输入数据进行一定次数的算术运算，得到用于访问数组的索引。
（3）对数组进行读/写操作
在没有对索引值进行完备验证的情况下，错误地用索引值对数组进行读/写操作。当索引值大于数组实际长度时，发生数组越界。
数组越界漏洞的根本原因是访问数组时使用的索引值受到输入数据影响，例如CVE-2010-2110漏洞触发的原理就是数组越界。 

## Bypass漏洞

Bypass漏洞翻译过来就是“绕过漏洞”。听起来是很怪异的一个名字，其实这个名字包含了很多意思。
	假设有一个软件，它只允许管理员登录，不允许其他人登录。可是，你发现利用某种方法，即使你不知道管理员的密码，你也能够登录该软件，这个时候，你就发现了一个“登录限制绕过漏洞”。
	假设又有一个软件，它限制你访问某些特定的文件，如被加密的文件。可是，你发现利用修改文件属性的方法可以使得你能够访问特定的被加密文件，这个时候，你绕过了软件的限制，就又发现了一个“文件限制绕过漏洞”。
	总的来说，Bypass漏洞是一个大类，它包含了很多小类，这些小类有一个共同的特点，就是这些出现问题的软件在使用上都存在对用户使用的限制，而Bypass漏洞就可以绕过软件的限制，使得软件的限制形同虚设。
	你可能觉得Bypass漏洞的危害好像不大，不知道你听说过微软Windows2000系统的一个漏洞没有。这个漏洞可以让你在不知道别人系统密码的情况下，成功地访问到系统内部的所有文件与数据信息，这就是Windows2000系统的输入法漏洞。
	Windows2000系统的输入法漏洞允许用户在不知道系统密码的情况下，在输入用户名的窗口中调出“帮助”程序，借助“帮助”程序的“调至URL”功能，访问到系统的任意一个文件。
	想一想，当你给自己的Windows2000系统设定了一个密码，放心离开办公室回家的时候，一个恶意的访问者正通过输入法漏洞，访问到你系统中保存的机密信息，你会觉得这样的危害还不大吗？
	不要以为Windows2000系统的这个输入法漏洞早已经过时，著名的谷歌输入法在前一阵子也出现了同样的漏洞，只要安装了谷歌输入法的操作系统，不论你是Windows XP，还是Windows Vista，别人都可以在不知道你系统密码的情况下访问你系统中的任意一个文件。这下子你知道Bypass漏洞的危害有多大了吧！
	对于那些安全软件来说，Bypass漏洞更加具有危害性。例如杀毒软件，一个原本是病毒的文件，由于杀毒软件存在Bypass漏洞，该病毒文件竟然绕过了被杀毒软件发现的安全保护机制，用户相信杀毒软件没有警告的文件一定是安全的，于是会放心运行该病毒文件，后果可想而知。
	Bypass漏洞不但可以让普通软件的限制功能作废，还可能造成某些软件完全形同虚设，长此以往，用户肯定会失去对软件功能的信任，从而造成软件无法卖出，使开发商蒙受巨大的损失。 


















































---
更多详情请见原书。《漏洞利用与渗透测试基础》
**友情链接**：[原书购买地址]( https://detail.tmall.com/item.htm?spm=0.0.0.0.tZriNw&id=545402369740
)